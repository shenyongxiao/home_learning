# 面试题汇总

#### 1.如何解决图片带来的oom问题？

图片的内存大小的计算方式是图片的长*宽*设备分辨率/资源目录分辨率^2*单位像素所占的字节数。图片带来的oom问题归根结底是由于图片内存占用过大。解决方案有以下几种：

a.使用低色彩的解析模式，例如RGB565减少单个像素的字节大小 

b.资源文件放在合理的位置 

c.利用BitmapFactory的inSampleSize进行对应的大小缩放 

d.使用LruCache和DiskLruCache进行内存缓存及磁盘内存缓存。

#### 2.如何知道一张图片所占的内存？

图片的内存大小的计算方式：图片的高 x 图片的宽 x（设备的分辨率/资源文件的分辨率）^2 x 单位像素所占的字节数。

#### 3.如果多线程中引用单例模式，会引发什么后果？如何解决？

看对应的单例模式是否是线程安全的单例模式，例如一般的懒汉的单例模式，就可能出现线程安全问题，如果是双重锁校验类的单例模式就不会出现线程安全问题；将对应的单例模式变成对应的线程安全的单例模式即可，即加上同步锁，或者换成线程安全的单例模式如双重锁校验的单例模式。

#### 4.在子线程中new Handler 会怎么样？

直接new Handler会报looper为空的异常的，Handler的初始化底层源码会调用当前线程的获取Looper实例，子线程中没有对应的Looper就会报异常。想让它能正常使用，可以在对应子线程中创建一个Looper对象。

#### 5.android6.0的权限适配，android8.0的权限适配

#### 6.dp与px之间的关系

dpi=（根号下 （屏幕宽^2 + 屏幕高^2））/屏幕尺寸（对角线长度 inch）	单位 dpi=px/inch

density = dpi/160

android中的dp在渲染前会将dp转为px，计算公式：

- px = density * dp;
- density = dpi / 160;
- px = dp * (dpi / 160);

而dpi是根据屏幕真实的分辨率和尺寸来计算的，每个设备都可能不一样的。

#### 7.屏幕分辨率的适配

1.两种方式通过最小smallestWidth进行适配，利用的是穷举适配dimen文件的方式，value-sw360dp类型的资源文件，有一定的容错机制，不存在对应的大小文件，系统会自动向下寻找适合的文件。

2.今日头条的适配方案，通过代码侵入修改density的值以达到适配的目的，具体保留一份dimens文件，在对应的activity加载的onCreate的方法中计算对应的设备的density的值，并赋值给系统的density的值。

#### 8.Service有几种启动方式？他们的生命周期又如何？

两种启动方式，startService和bindService。

1.startService启动会调用service oncreate方法和onstartCommad方法，多次startService方法只会调用一次onCreate方法，会多次调用 onstartCommad方法。

2.bindService启动会调用service oncreate方法和onBind方法，多次调用不会调用其他方法了。

#### 9.android5.0 之后隐式启动Service会造成什么后果？如何解决？

service隐式启动（即通过setAction进行启动）无法正常启动，源码中对隐式启动service的逻辑做了抛出异常处理，解决方法显示的启动service或者在的启动的Intent中设置action和包名，或者设置ComponentName(里面包括包名和service的名称)

#### 10.有过多线程的编程经验吗？(线程池之类的)

常见的四个线程池：

1.FixedThreadPool:核心线程池数等于总线程数，任务队列没有大小限制，核心线程没有超时机制。

2.CachedThreadPool：只有非核心线程，线程数无限制，线程池空闲线程有超时机制，超过六十秒会回收对应的空线程，这个线程池会立即处理对应的进入线程池的线程，所以其对应的存储任务的队列无法存储元素。

3.ScheduledThreadPool：核心线程数固定，非核心线程数无限制，用于执行定时任务和具有周期的重复任务。

4.SingleThreadExecutor：只有一个核心线程，确保所有任务都在同一个线程中按顺序执行。

#### 11.说说Java中的设计原则

六大设计原则：

1.单一职责原则：

2.里式替换原则：

3.依赖倒置原则：

4.接口隔离原则：

5.迪米特法则：

6.开闭原则：

#### 12.String  类型能不能继承？如果能继承，如何才能让它不被继承？

不能被继承，因为String类有final修饰符。而final修饰的类是不能被继承的。

#### 13.说说图片框架的缓存原理?(我这边是以Fresco 为例)

以Glide为例，它的缓存是内存缓存和磁盘缓存相结合的缓存方式进行缓存的

1.缓存key的值由多个参数决定即时改动图片加载的宽度对应的key值也会不一样。

2.gldie的内存缓存，使用的是LruCache算法，具体对应glide中的LruResourceCache类，在加载图片的时候先从内存缓存中取图片数据，然后将数据存储于弱引用缓存的HashMap中，在源码中有记录数据是否正在被使用，使用的话会被存储在弱引用缓存中，未被使用则会存储于LruResourcesCache中。

3.glide的硬盘缓存，使用的是DiskLruCache。

#### 14.如何理解Java的多态？其中重载和重写有什么区别？

多态是同一个行为具有多个不同表现形式或形态的能力，多态是同一个接口，使用不同的实例而执行不同操作，多态就是程序运行期间才确定，一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法。
多态存在的三个必要条件是：继承，重写，父类引用指向子类引用。
多态的三个实现方式是：重写，接口，抽象类和抽象方法。

重写(Override)和重载(Overload)的区别

![](D:\学习\面试相关\微信图片_重载和重写的区别.png)

#### 15.谈一下JVM内存区域划分？哪部分是线程公有的，哪部分是私有的？

JVM 的内存区域可以分为两类：线程私有和区域和线程共有的区域。 线程私有的区域：程序计数器、JVM 虚拟机栈、本地方法栈；线程共有的区域：堆、方法区、运行时常量池。

- 程序计数器，也有称作PC寄存器。每个线程都有一个私有的程序计数器，任何时间一个线程都只会有一个方法正在执行，也就是所谓的当前方法。程序计数器存放的就是这个当前方法的JVM指令地址。当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。
  JVM虚拟机栈。创建线程的时候会创建线程内的虚拟机栈，栈中存放着一个个的栈帧，对应着一个个方法的调用。JVM 虚拟机栈有两种操作，分别是压栈和出站。栈帧中存放着局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。
- 本地方法栈。本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。
  堆。堆是内存管理的核心区域，用来存放对象实例。几乎所有创建的对象实例都会直接分配到堆上。所以堆也是垃圾回收的主要区域，垃圾收集器会对堆有着更细的划分，最常见的就是把堆划分为新生代和老年代。java堆允许处于不连续的物理内存空间中，只要逻辑连续即可。堆中如果没有空间完成实例分配无法扩展时将会抛出OutOfMemoryError异常。
- 方法区。方法区与堆一样所有线程所共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。

其实除了程序计数器，其他的部分都会发生 OOM。

- 堆。 通常发生的 OOM 都会发生在堆中，最常见的可能导致 OOM 的原因就是内存泄漏。
- JVM虚拟机栈和本地方法栈。 当我们写一个递归方法，这个递归方法没有循环终止条件，最终会导致  StackOverflow 的错误。当然，如果栈空间扩展失败，也是会发生 OOM 的。
- 方法区。方法区现在基本上不太会发生 OOM，但在早期内存中加载的类信息过多的情况下也是会发生 OOM 的。

#### 16.final关键字的用法？

final 可以修饰类、变量和方法。修饰类代表这个类不可被继承。修饰变量代表此变量不可被改变。修饰方法表示此方法不可被重写 (override)。

#### 17.死锁是怎么导致的？如何定位死锁

某个任务在等待另一个任务，而后者又等待别的任务，这样一直下去，直到这个链条上的任务又在等待第一个任务释放锁。这得到了一个任务之间互相等待的连续循环，没有哪个线程能继续。这被称之为死锁。当以下四个条件同时满足时，就会产生死锁：
(1) 互斥条件。任务所使用的资源中至少有一个是不能共享的。
(2) 任务必须持有一个资源，同时等待获取另一个被别的任务占有的资源。
(3) 资源不能被强占。
(4) 必须有循环等待。一个任务正在等待另一个任务所持有的资源，后者又在等待别的任务所持有的资源，这样一直下去，直到有一个任务在等待第一个任务所持有的资源，使得大家都被锁住。
要解决死锁问题，必须打破上面四个条件的其中之一。在程序中，最容易打破的往往是第四个条件。

#### 18.数据库如何进行升级，SQLite增删改查的基础sql语句

在SQLiteOpenHelper的构造函数中，包含了一个version的参数。这个参数即是数据库的版本。 所以，我们可以通过修改version来实现数据库的升级。 当version大于原数据库版本时，onUpgrade()会被触发，可以在该方法中编写数据库升级逻辑。具体的数据库升级逻辑示例可参考这里。
常用的SQL增删改查：

增：INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….)
删： DELETE FROM 表名称 WHERE 列名称 = 值
改：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
查：SELECT 列名称（通配是*符号） FROM 表名称

ps:操作数据表是:ALTER TABLE。该语句用于在已有的表中添加、修改或删除列。
ALTER TABLE table_name ADD column_name datatype
ALTER TABLE table_name DROP COLUMN column_name
ALTER TABLE table_name_old RENAME TO table_name_new

#### 19.Broadcast的分类？有序，无序？粘性，非粘性？本地广播？

- 广播可以分为有序广播、无序广播、本地广播、粘性广播。其中无序广播通过sendBroadcast(intent)发送，有序广播通过sendOrderedBroadcast(intent)发送。
- 有序广播。
  (1) 有序广播可以用priority来调整优先级   取值范围-1000~+1000，默认为0，数值越大优先级越高，优先级越高越优先获得广播响应。
  (2) abortBroadcast()可来终止该广播的传播，对更低优先级的屏蔽，注意只对有序广播生效。
  (3) 有序广播在传播数据中会发生比如setResultData()，getResultData()，在传播过程中，可以从新设置数据
- 关于本地广播，可以查看这篇文章。总的来说，本地广播是通过LocalBroadcastManager内置的Handler来实现的，只是利用了IntentFilter的match功能，至于BroadcastReceiver 换成其他接口也无所谓，顺便利用了现成的类和概念而已。在register()的时候保存BroadcastReceiver以及对应的IntentFilter，在sendBroadcast()的时候找到和Intent对应的BroadcastReceiver，然后通过Handler发送消息，触发executePendingBroadcasts()函数，再在后者中调用对应BroadcastReceiver的onReceive()方法。
- 粘性消息：粘性消息在发送后就一直存在于系统的消息容器里面，等待对应的处理器去处理，如果暂时没有处理器处理这个消息则一直在消息容器里面处于等待状态，粘性广播的Receiver如果被销毁，那么下次重建时会自动接收到消息数据。(在 android 5.0/api 21中deprecated,不再推荐使用，相应的还有粘性有序广播，同样已经deprecated)

#### 20.Android中的事件传递机制？

当我们的手指触碰到屏幕，事件是按照Activity->ViewGroup->View这样的流程到达最终响应触摸事件的View的。而在事件分发过程中，涉及到三个最重要的方法：dispatchTouchEvent()、onInterceptTouchEvent()、onTouchEvent。我们的手指触摸到屏幕的时候，会触发一个Action_Down类型的事件，当前页面的Activity会首先做出相应，也就是说会走到Activity的dispatchTouchEvent()方法内。在这个方法内部有下面两个逻辑：

- 调用getWindow.superDispatchTouchEvent()。
- 如果上一步返回true，则直接返回true；否则return自己的onTouchEvent()。显然，当getWindow.superDispatchTouchEvent()返回true，表示当前事件已经被消费掉，无需调用onTouchEvent；否则代表事件并没有被处理，因此需要调用Activity的onTouchEvent进行处理。
  我们都知道，getWindow()返回的是PhoneWindow，因此这句代码本质上调用了PhoneWindow中的superDispatchTouchEvent()。而后者实际上调用了mDecor.superDispatchTouchEvent(event)。这个mDecor也就是DecorView，它是FrameLayout的一个子类。在DecorView中的superDispatchTouchEvent(event)中调用的是super.dispatchTouchEvent()。因此，本质上调用的是ViewGroup的dispatchTouchEvent()。

到这里，事件已经从Activity传递到ViewGroup了。接下来我们分析ViewGroup。
在ViewGroup的dispatchTouchEvent()中逻辑大致如下：

- 通过onInterceptTouchEvent()判断当前ViewGroup是否拦截，默认的ViewGroup都是不拦截的；
- 如果拦截，则return自己的onTouchEvent()；
- 如果不拦截，则根据child.dispatchTouchEvent()的返回值判断。如果返回true，则return true；否则return自身的onTouchEvent()，在这里实现了未处理事件的向上传递。

通常情况下，ViewGroup的onInterceptTouchEvent()都返回false，表示不拦截。这里需要注意的是事件序列，比如Down事件、Move事件…Up事件，从Down到Up是一个完整的事件序列，对应着手指从按下到抬起这一系列事件，如果ViewGroup拦截了Down事件，那么后续事件都会交给这个ViewGroup的onTouchEvent。如果ViewGroup拦截的不是Down事件，那么会给之前处理这个Down事件的View发送一个Action_Cancel类型的事件，通知子View这个后续的事件序列已经被ViewGroup接管了，子View恢复之前的状态即可。
这里举一个常见的例子：在一个 Recyclerview 中有很多的 Button，我们首先按下了一个 button，然后滑动一段距离再松开，这时候 Recyclerview 会跟着滑动，并不会触发这个 button 的点击事件。这个例子中，当我们按下 button 时，这个 button 接收到了 Action_Down 事件，正常情况下后续的事件序列应该由这个 button处理。但我们滑动了一段距离，这时  Recyclerview 察觉到这是一个滑动操作，拦截了这个事件序列，走了自身的 onTouchEvent()方法，反映在屏幕上就是列表的滑动。而这时 button 仍然处于按下的状态，所以在拦截的时候需要发送一个 Action_Cancel 来通知 button 恢复之前状态。
事件分发最终会走到View的dispatchTouchEvent()中。在View的dispatchTouchEvent()中没有onInterceptTouchEvent()，这里很容易理解，View没有child，也就不存在拦截。View的dispatchTouchEvent()直接return了自己的onTouchEvent()。如果onTouchEvent()返回true代表事件被消费，否则未消费的事件会向上传递，直到有View处理了事件或一直没有消费，最终回到Activity的onTouchEvent()终止。
有时候会有人混淆onTouchEvent和onTouch。首先，这两个方法都在View的dispatchTouchEvent()中：

- 如果touchListener不为null，并且这个View是enable的，而且onTouch返回true，都满足时直接return true，走不到onTouchEvent()方法。
- 否则，就会触发onTouchEvent()。因此onTouch优先于onTouchEvent获得事件处理权。

![](D:\学习\面试相关\微信图片_view的事件传递机制.jpg)

#### 21.Handler的原理？

与Handler密切相关的还有Message、MessageQueue、Looper。

- Message。Message有两个关键的成员变量：target、callback：
  (1) target。就是发送消息的Handler
  (2) callback。调用Handler.post(Runnable)时传入的Runnable类型的任务。post事件的本质也是创建了一个Message，将我们传入的这个runnable赋值给创建的Message的callback这个成员变量。
- MessageQueue。消息队列用于存放消息，其中重点关注next()方法，它会返回下一个待处理的消息。
- Looper。Looper消息轮询器其实是连接Handler和消息队列的核心。想要在一个线程中创建一个Handler，首先要通过Looper.prepare()创建Looper，之后还得调用Looper.loop()开启轮询。
  (1) prepare()。这个方法做了两件事：首先通过ThreadLocal.get()获取当前线程中的Looper，如果不为空则抛出RuntimeException。否则创建Looper，并通过ThreadLocal.set(looper)将当前线程与刚刚创建的Looper绑定。值得注意的是，上面的消息队列的创建其实就是发生在Looper的构造函数中。
  (2)loop()。这个方法开启了整个事件机制的轮询。其本质是开启一个死循环，不断地通过MessageQueue的next()方法获取消息msg。拿到消息后会调用msg.target.dispatchMessage()来做处理。综上也就是调用handler.dispatchMessage()。
- Handler。Handler重点在于发送消息和处理消息。
  (1)发送消息。其实发送消息除了 sendMessage 之外还有 sendMessageDelayed 和 post 以及 postDelayed 等等不同的方式。但它们的本质都是调用了 sendMessageAtTime。在 sendMessageAtTime 这个方法中调用了 enqueueMessage。在 enqueueMessage 这个方法中做了两件事：通过 msg.target = this 实现了消息与当前 handler 的绑定。然后通过 queue.enqueueMessage 实现了消息入队。
  (2)处理消息。 消息处理的核心其实就是dispatchMessage()这个方法。这个方法里面的逻辑很简单，先判断 msg.callback 是否为 null，如果不为空则执行这个 runnable。如果为空则会执行我们的handleMessage方法。

#### 22.ANR出现的情况有几种？ 怎么分析解决ANR问题

ANR(Application Not responding)。Android中，主线程(UI线程)如果在规定时内没有处理完相应工作，就会出现ANR。具体来说，ANR会在以下几种情况中出现:
(1) 输入事件(按键和触摸事件)5s内没被处理
(2) BroadcastReceiver的事件(onRecieve方法)在规定时间内没处理完(前台广播为10s，后台广播为60s)
(3) service 前台20s后台200s未完成启动
(4) ContentProvider的publish在10s内没进行完

#### 23.内存泄露的场景有哪些？内存泄漏分析工具使用方法？

常见的内存泄露有：

- 单例模式引起的内存泄露。
- 静态变量导致的内存泄露。
- 非静态内部类引起的内存泄露。
- 使用资源时，未及时关闭引起内存泄露。
- 使用属性动画引起的内存泄露。
- Webview导致的内存泄露。

而对于内存泄露的检测，常用的工具有LeakCanary、MAT（Memory Analyer Tools）、Android Studio自带的Profiler。关于用法，网上教程很多，可自行查阅，下面两个经供参考：
三种用法、MAT
同时附上官方Android Profiler教程

#### 24.如何实现启动优化，有什么工具可以使用？

#### 25.说下Activity的生命周期？

技术点：Activity生命周期

思路：分条解释Activity从创建到销毁整个生命周期中涉及到的方法及作用

参考回答：在Activity的生命周期涉及到七大方法，分别是： 

- onCreate()表示Activity **正在创建**，常做**初始化**工作，如setContentView界面资源、初始化数据
- onStart()表示Activity **正在启动**，这时Activity **可见但不在前台**，无法和用户交互
- onResume()表示Activity **获得焦点**，此时Activity **可见且在前台**并开始活动
- onPause()表示Activity **正在停止**，可做 **数据存储、停止动画**等操作
- onStop()表示activity **即将停止**，可做**稍微重量级回收工作**，如取消网络连接、注销广播接收器等
- onDestroy()表示Activity **即将销毁**，常做**回收工作、资源释放** 
- 另外，当Activity由后台切换到前台，由不可见到可见时会调用onRestart()，表示Activity **重新启动**

#### 26.谈谈onSaveInstanceState()方法？何时会调用？

技术点：Activity重建

思路：可从使用场景、调用次序上解释

参考回答：当非人为终止Activity时，比如系统配置发生改变时导致Activity被杀死并重新创建、资源内存不足导致低优先级的Activity被杀死，会调用 **onSavaInstanceState()** 来保存状态。该方法调用在onStop之前，但和onPause没有时序关系。

引申：可再谈谈它和onRestoreInstanceState()的关系以及后者的作用

#### 27.如何避免配置改变时Activity重建？

技术点：Activity重建

思路：一种解决思路是设置配置文件中Activity的configChanges属性

参考回答：为了避免由于配置改变导致Activity重建，可在AndroidManifest.xml中对应的Activity中设置**android:configChanges="orientation|screenSize"**。此时再次旋转屏幕时，该Activity不会被系统杀死和重建，只会调用onConfigurationChanged。因此，当配置程序需要响应配置改变，指定**configChanges属性**，重写onConfigurationChanged方法即可。

#### 28.优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？

技术点：Activity重建

思路：可从Activity重建会被调用的方法出发

参考回答：优先级低的Activity在内存不足被回收后重新打开会引发Activity重建。Activity被重新创建时会调用**onRestoreInstanceState**（该方法在onStart之后），并将onSavaInstanceState保存的**Bundle**对象作为参数传到onRestoreInstanceState与onCreate方法。因此可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断Activity是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断savedInstanceState是否为空。另外，谷歌更推荐使用onRestoreInstanceState进行数据恢复。

#### 29.说下Activity的四种启动模式？（有时会出个实际问题来分析返回栈中Activity的情况）

技术点：Activity启动模式

思路：分条解释四个启动模式的特点

参考回答： 

- standard标准模式：每次启动一个Activity就会创建一个新的实例
- singleTop栈顶复用模式：如果新Activity已经位于任务栈的栈顶，就不会重新创建，并回调 **onNewIntent(intent)** 方法
- singleTask栈内复用模式：只要该Activity在一个任务栈中存在，都不会重新创建，并回调 **onNewIntent(intent)** 方法。如果不存在，系统会先寻找是否存在需要的栈，如果不存在该栈，就创建一个任务栈，并把该Activity放进去；如果存在，就会创建到已经存在的栈中
- singleInstance单实例模式：具有此模式的Activity只能单独位于一个任务栈中，且此任务栈中只有**唯一**一个实例

#### 30.Activity的启动过程？

技术点：Activity启动、ActivityManagerServie、ApplicationThread

思路：可大致介绍Activity启动过程涉及到的类，尤其是ActivityManagerServie、ApplicationThread从中发挥的作用。详见[要点提炼|开发艺术之四大组件](https://www.jianshu.com/p/37f366064b98) 

参考回答：调用startActivity()后经过重重方法会转移到ActivityManagerService的startActivity()，并通过一个IPC回到ActivityThread的内部类**ApplicationThread**中，并调用其scheduleLaunchActivity()将启动Activity的消息发送并交由**Handler H**处理。Handler H对消息的处理会调用handleLaunchActivity()->performLaunchActivity()得以完成Activity对象的创建和启动。

引申：由于ActivityManagerService是一个Binder对象，可引申谈谈Binder机制

#### 31.谈一谈Fragment的生命周期？

技术点：Fragment生命周期

思路：分条解释Fragment从创建到销毁整个生命周期中涉及到的方法及作用

参考回答：Fragment从创建到销毁整个生命周期中涉及到的方法依次为：onAttach()->onCreate()-> onCreateView()->onActivityCreated()->onStart()->onResume()->onPause()->onStop()->onDestroyView()->onDestroy()->onDetach()，其中和Activity有不少名称相同作用相似的方法，而不同的方法有: 

-  **onAttach()**：当Fragment和Activity建立关联时调用
-  **onCreateView()**：当Fragment创建视图时调用
-  **onActivityCreated()**：当与Fragment相关联的Activity完成onCreate()之后调用
-  **onDestroyView()**：在Fragment中的布局被移除时调用
-  **onDetach()**：当Fragment和Activity解除关联时调用

#### 32.Activity和Fragment的异同？

技术点：Fragment作用

思路：分别解释“异”“同”

参考回答： 

- Activity和Fragment的相似点在于，它们都可包含布局、可有自己的生命周期，Fragment可看似迷你活动。
- 不同点是，由于Fragment是依附在Activity上的，多了些和宿主Activity相关的生命周期方法，如onAttach()、onActivityCreated()、onDetach()；另外，Fragment的生命周期方法是由宿主Activity而不是操作系统调用的，Activity中生命周期方法都是protected，而Fragment都是public，也能印证了这一点，因为Activity需要调用Fragment那些方法并管理它。

引申：可具体谈谈Activity和Fragment的关系

#### 33.Activity和Fragment的关系？

技术点：Fragment作用

思路：可从Fragment出现的目的、两者数量关系、调用关系展开

参考回答： 

- 正如Fragment的名字“碎片”，它的出现是为了解决Android碎片化 ，它可作为Activity界面的组成部分，可在Activity运行中实现动态地加入、移除和交换。
- 一个Activity中可同时出现多个Fragment，一个Fragment也可在多个Activity中使用。
- 另外，Activity的**FragmentManager**负责调用队列中Fragment的生命周期方法，只要Fragment的状态与Activity的状态保持了同步，宿主Activity的FragmentManager便会继续调用其他生命周期方法以继续保持Fragment与Activity的状态一致。

#### 34.Service的两种启动方式？区别在哪？

技术点：Service生命周期

思路：分别解释两种启动模式如何启动和停止Service，并引起生命周期怎样的变化

参考回答： 

- 第一种，其他组件调用Context的 **startService()** 方法可以启动一个Service，并回调服务中的onStartCommand()。如果该服务之前还没创建，那么回调的顺序是onCreate()->onStartCommand()。服务启动了之后会一直保持运行状态，直到 **stopService()** 或 **stopSelf()** 方法被调用，服务停止并回调onDestroy()。另外，无论调用多少次startService()方法，只需调用一次stopService()或stopSelf()方法，服务就会停止了。
- 第二种，其它组件调用Context的 **bindService()** 可以绑定一个Service，并回调服务中的onBind()方法。类似地，如果该服务之前还没创建，那么回调的顺序是onCreate()->onBind()。之后，调用方可以获取到onBind()方法里返回的IBinder对象的实例，从而实现和服务进行通信。只要调用方和服务之间的连接没有断开，服务就会一直保持运行状态，直到调用了 **unbindService()** 方法服务会停止，回调顺序onUnBind()->onDestroy()。

#### 35.一个Activty先start一个Service后，再bind时会回调什么方法？此时如何做才能回调Service的destory()方法？

技术点：Service生命周期

参考回答：startService()启动Service之后，再bindService()绑定，此时只会回调onBind()方法；若想回调Service的destory()方法，需要同时调用 stopService()和 unbindService()方法才能让服务销毁掉。

#### 36.AlarmManager能实现定时的原理？

技术点：系统服务（后台定时）

思路：AlarmManager

参考回答：通过调用AlarmManager的 **set()** 方法就可以设置一个定时任务，并提供三个参数（工作类型，定时任务触发的时间，PendingIntent对象）。其中第三个PendingIntent对象是关键，一般会调用它的 **getBroadcast()** 方法来获取一个能够执行广播的PendingIntent。这样当定时任务被触发的时候，广播接收器的onReceive()方法就可以得到执行。即通过服务和广播的循环触发实现定时服务。

#### 37.前台服务是什么？和普通服务的不同？如何去开启一个前台服务？

技术点：Service类型（前台Service）

参考回答：和一般运行在后台的服务不同，前台服务的服务状态可以被用户一眼看到。它和普通服务最大的区别是，前者会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果，且当系统内存不足服务被杀死时，通知会被移除。实现一个前台服务也非常简单，和发送一个通知非常类似，只不过在构建好一个Notification之后，不需要NotificationManager将通知显示出来，而是调用了 **startForeground()** 方法。

#### 38.是否了解ActivityManagerService，谈谈它发挥什么作用？

技术点：Service类型（ActivityManagerService）

思路：可谈谈在四大组件创建中ActivityManagerService发挥的作用，详见[要点提炼|开发艺术之四大组件](https://www.jianshu.com/p/37f366064b98) 

参考回答：ActivityManagerService是Android中最核心的服务 ， 主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块类似。

引申：看源码谈谈AMS启动过程：[ActivityManagerService分析——AMS启动流程](https://blog.csdn.net/dutedehuai/article/details/53495185)

#### 39.如何保证Service不被杀死？

技术点：Service应用

思路：列举几种解决办法

参考回答：可以采取以下几种解决方法： 

- 在Service的onStartCommand()中设置flages值为START_STICKY，使得Service被杀死后尝试再次启动Service
- 提升Service优先级，比如设置为一个前台服务
- 在Activity的onDestroy()通过发送广播，并在广播接收器的onReceive()中启动Service

#### 40.广播有几种形式？什么特点？

技术点：Broadcast类型

思路：分条解释每种广播类型的特点

参考回答：常见以下四种广播： 

- 普通广播：一种**完全异步**执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们接收的先后是随机的。
- 有序广播：一种**同步执行**的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递，所以此时的广播接收器是有先后顺序的，且优先级（priority）高的广播接收器会先收到广播消息。有序广播可以被接收器截断使得后面的接收器无法收到它。
- 本地广播：发出的广播只能够在应用程序的**内部**进行传递，并且广播接收器也只能接收本应用程序发出的广播。
- 粘性广播：这种广播会一直滞留，当有匹配该广播的接收器被注册后，该接收器就会收到此条广播。

#### 41.广播的两种注册形式？区别在哪？

技术点：Broadcast使用

参考回答：广播的注册有两种方法：一种在活动里通过代码**动态注册**，另一种在配置文件里**静态注册**。两种方式的相同点是都完成了对接收器以及它能接收的广播值这两个值的定义；不同点是动态注册的接收器必须要在程序启动之后才能接收到广播，而静态注册的接收器即便程序未启动也能接收到广播，比如想接收到手机开机完成后系统发出的广播就只能用静态注册了。

#### 42.ContentProvider了解多少？

技术点：ContentProvider

思路：ContentProvider功能

参考回答：作为四大组件之一，ContentProvider主要负责存储和共享数据。与文件存储、SharedPreferences存储、SQLite数据库存储这几种数据存储方法不同的是，后者保存下的数据只能被该应用程序使用，而前者可以让不同应用程序之间进行数据共享，它还可以选择只对哪一部分数据进行共享，从而保证程序中的隐私数据不会有泄漏风险。

引申：谈谈ContentProvider底层使用Binder机制原理

#### 43.Android中提供哪些数据持久存储的方法？

技术点：数据持久化

思路：分条解释每种数据持久存储的特点

参考回答：Android平台实现数据存储的常见几种方式： 

- File 文件存储：写入和读取文件的方法和 Java中实现I/O的程序一样。
- SharedPreferences存储：一种轻型的数据存储方式，常用来存储一些简单的配置信息，本质是基于XML文件存储key-value键值对数据。
- SQLite数据库存储：一款轻量级的关系型数据库，它的运算速度非常快，占用资源很少，在存储大量复杂的关系型数据的时可以使用。
- ContentProvider：四大组件之一，用于数据的存储和共享，不仅可以让不同应用程序之间进行数据共享，还可以选择只对哪一部分数据进行共享，可保证程序中的隐私数据不会有泄漏风险。

#### 44.了解SQLite中的事务处理吗？是如何做的？

技术点：数据持久化（SQLite）

参考回答：SQLite在做CRDU操作时都默认开启了事务，然后把SQL语句翻译成对应的SQLiteStatement并调用其相应的CRUD方法，此时整个操作还是在rollback journal这个临时文件上进行，只有操作顺利完成才会更新.db数据库，否则会被回滚。

引申：谈谈如何模仿SQLite中事务的思想更高效进行批量操作。

#### 45.如果现在要删除SQLite中表的一个字段如何做？

技术点：数据持久化（SQLite）

参考回答：SQLite数据库只允许增加表字段而不允许修改和删除表字段，只能采取复制表思想，即创建一个新表保留原表想要的字段、再将原表删除

#### 46.Android中进程和线程的关系？

技术点：进程、线程

参考回答： 

- 形象理解：如果把安卓系统比喻成一片土壤，可以把App看做扎根在这片土壤上的工厂，每个APP一般对应一个进程，那么线程就像是工厂的生产线。其中，主线程好比是主生产线，只有一条，子线程就像是副生产线，可以有很多条。
- 关系：一个APP一般对应一个进程和有限个线程 
  - 一般对应一个进程，当然，可以在AndroidMenifest中给四大组件指定属性`android:process`开启多进程模式
  - 有限个线程：线程是一种**受限**的系统资源，不可无限制的产生且线程的创建和销毁都有一定的开销。

#### 47.为何需要进行IPC？多进程通信可能会出现什么问题？

技术点：多进程通信

思路：讨论多进程通信会出现的问题得出IPC的必要性

参考回答：

（1）

多进程造成的影响

可总结为以下四方面： 

- 静态变量和单例模式失效：由独立的虚拟机造成
- 线程同步机制失效：由独立的虚拟机造成
- SharedPreference的不可靠下降：不支持两个进程同时进行读写操作，即不支持并发读写，有一定几率导致数据丢失
- Application多次创建： Android系统会为新的进程分配独立虚拟机，相当于系统又把这个应用重新启动了一次。

（2）**需要进程间通信的必要性**：所有运行在不同进程的四大组件，只要它们之间需要通过内存在共享数据，都会共享失败。这是由于Android为每个应用分配了**独立**的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这会导致在不同的虚拟机中访问同一个类的对象会产生多份副本。

引申： 谈谈IPC的使用场景

#### 48.什么是序列化？Serializable接口和Parcelable接口的区别？为何推荐使用后者？

技术点：序列化

参考回答：序列化表示将一个对象转换成

可存储或可传输

的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。 

- 应用场景：需要通过Intent和Binder等传输**类对象**就必须完成对象的序列化过程。

- 两种方式：实现Serializable/Parcelable接口。不同点如图：

  ![](D:\学习\面试相关\微信图片_序列化相关.png)

  

#### 47.Android中为何新Binder来作为主要的IPC方式？

技术点：Binder机制

思路：回答Binder优点

参考回答：Binder机制有什么几条

优点

： 

- 传输效率高、可操作性强：传输效率主要影响因素是内存拷贝的次数，拷贝次数越少，传输速率越高。从Android进程架构角度分析：对于消息队列、Socket和管道来说，数据先从发送方的缓存区拷贝到内核开辟的缓存区中，再从内核缓存区拷贝到接收方的缓存区，一共两次拷贝，如图：

  

  ![img](https:////upload-images.jianshu.io/upload_images/5494434-85e1d40a824a3781?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp)

  

  而对于Binder来说，数据从发送方的缓存区拷贝到内核的缓存区，而接收方的缓存区与内核的缓存区是映射到同一块物理地址的，节省了一次数据拷贝的过程，如图：

  

  ![img](https:////upload-images.jianshu.io/upload_images/5494434-9fc421f59d455dd1?imageMogr2/auto-orient/strip%7CimageView2/2/w/485/format/webp)

  

   由于共享内存操作复杂，综合来看，Binder的传输效率是最好的。

- 实现C/S架构方便：Linux的众IPC方式除了Socket以外都不是基于C/S架构，而Socket主要用于网络间的通信且传输效率较低。Binder基于C/S架构 ，Server端与Client端相对独立，稳定性较好。

- 安全性高：传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；而Binder机制为每个进程分配了UID/PID且在Binder通信时会根据UID/PID进行有效性检测。

#### 48.使用Binder进行数据传输的具体过程？

技术点：Binder机制

思路：通过AIDL实现方式解释Binder数据传输的具体过程

参考回答：服务端中的Service给与其绑定的客户端提供Binder对象，客户端通过AIDL接口中的asInterface()将这个Binder对象转换为代理Proxy，并通过它发起RPC请求。客户端发起请求时会挂起当前线程，并将参数写入data然后调用transact()，RPC请求会通过系统底层封装后由服务端的onTransact()处理，并将结果写入reply，最后返回调用结果并唤醒客户端线程。



![img](https:////upload-images.jianshu.io/upload_images/5494434-ae0fea52363657da?imageMogr2/auto-orient/strip%7CimageView2/2/w/619/format/webp)

#### 49.Binder框架中ServiceManager的作用？

技术点：Binder机制

思路：从Binder框架出发讨论每个元素的作用

参考回答：在

Binder框架

定义了四个角色：Server，Client，ServiceManager和Binder驱动。其中Server、Client、ServiceManager运行于用户空间，Binder驱动运行于内核空间。关系如图：



![img](https:////upload-images.jianshu.io/upload_images/5494434-b7643fdec9e1ea6a?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp)



-  **Server**&**Client**：服务器&客户端。在Binder驱动和Service Manager提供的基础设施上，进行Client-Server之间的通信。

- ServiceManager

  服务的管理者，将Binder名字转换为Client中对该Binder的引用，使得Client可以通过Binder名字获得Server中Binder实体的引用。流程如图：

  

  ![img](https:////upload-images.jianshu.io/upload_images/5494434-95fed6e787189aa5?imageMogr2/auto-orient/strip%7CimageView2/2/w/556/format/webp)

  

- Binder驱动

  ： 

  - 与硬件设备没有关系，其工作方式与设备驱动程序是一样的，工作于内核态。
  - 提供**open()**、**mmap()**、**poll()**、**ioctl()** 等标准文件操作。
  - 以字符驱动设备中的misc设备注册在设备目录/dev下，用户通过/dev/binder访问该它。
  - 负责进程之间binder通信的建立，传递，计数管理以及数据的传递交互等底层支持。
  - 驱动和应用程序之间定义了一套接口协议，主要功能由**ioctl()** 接口实现，由于ioctl()灵活、方便且能够一次调用实现先写后读以满足同步交互，因此不必分别调用write()和read()接口。
  - 其代码位于linux目录的drivers/misc/binder.c中。

#### 50.Android中有哪些基于Binder的IPC方式？简单对比下？

- 技术点：IPC方式

- 思路：分析每种IPC方式的优缺点和使用场景的差异

- 参考回答：

  ![img](https://upload-images.jianshu.io/upload_images/5494434-7396b6aa84ba4c6c?imageMogr2/auto-orient/strip%7CimageView2/2/w/667/format/webp)

#### 51.是否了解AIDL？原理是什么？如何优化多模块都使用AIDL的情况？

技术点：AIDL

思路：

参考回答： 

- AIDL(Android Interface Definition Language，**Android接口定义语言**)：如果在一个进程中要调用另一个进程中对象的方法，可使用AIDL生成可序列化的参数，AIDL会生成一个服务端对象的**代理类**，通过它客户端实现间接调用服务端对象的方法。

- AIDL的

  本质

  是系统提供了一套可快速实现Binder的工具。关键类和方法： 

  -  **AIDL接口**：继承**IInterface**。

  -  **Stub类**：Binder的实现类，服务端通过这个类来提供服务。

  -  **Proxy类**：服务器的本地代理，客户端通过这个类调用服务器的方法。

  - asInterface()

    ：客户端调用，将服务端的返回的Binder对象，转换成客户端所需要的AIDL接口类型对象。返回对象： 

    - 若客户端和服务端位于同一进程，则直接返回Stub对象本身；
    - 否则，返回的是系统封装后的Stub.proxy对象。

  -  **asBinder()**：根据当前调用情况返回代理Proxy的Binder对象。

  -  **onTransact()**：运行服务端的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。

  -  **transact()**：运行在客户端，当客户端发起远程请求的同时将当前线程挂起。之后调用服务端的onTransact()直到远程请求返回，当前线程才继续执行。

- 当有多个业务模块都需要AIDL来进行IPC，此时需要为每个模块创建特定的aidl文件，那么相应的Service就会很多。必然会出现系统资源耗费严重、应用过度重量级的问题。解决办法是建立Binder连接池，即将每个业务模块的Binder请求

  统一

  转发到一个远程Service中去执行，从而避免重复创建Service。 

  - 工作原理：每个业务模块创建自己的AIDL接口并实现此接口，然后向服务端提供自己的唯一标识和其对应的Binder对象。服务端只需要一个Service，服务器提供一个queryBinder接口，它会根据业务模块的特征来返回相应的Binder对像，不同的业务模块拿到所需的Binder对象后就可进行远程方法的调用了。流程如图：

    

    ![img](https:////upload-images.jianshu.io/upload_images/5494434-927ba949cd159537?imageMogr2/auto-orient/strip%7CimageView2/2/w/751/format/webp)

#### 52.MotionEvent是什么？包含几种事件？什么条件下会产生？

技术点：View触控

参考回答：

MotionEvent

是手指触摸屏幕锁产生的一系列事件。包含的事件有： 

-  **ACTION_DOWN**：手指刚接触屏幕
-  **ACTION_MOVE**：手指在屏幕上滑动
-  **ACTION_UP**：手指在屏幕上松开的一瞬间
-  **ACTION_CANCEL**：手指保持按下操作，并从当前控件转移到外层控件时会触发

#### 53.scrollTo()和scrollBy()的区别？

技术点：View滑动

参考回答：scrollBy内部调用了scrollTo，它是基于当前位置的**相对滑动**；而scrollTo是**绝对滑动**，因此如果利用相同输入参数多次调用scrollTo()方法，由于View初始位置是不变只会出现一次View滚动的效果而不是多次。

引申：两者都只能对**view内容**进行滑动，而不能使view本身滑动，且非平滑，可使用Scroller有过渡滑动的效果

#### 54.Scroller中最重要的两个方法是什么？主要目的是？

技术点：View滑动

思路：从Scroller实现滑动的具体过程出发，

参考回答：Scroller实现滑动的具体过程： 

- 在MotionEvent.ACTION_UP事件触发时调用startScroll()方法，该方法并没有进行实际的滑动操作，而是记录滑动相关量

- 马上调用invalidate/postInvalidate()方法，请求View重绘，导致View.draw方法被执行

- 紧接着会调用View.computeScroll()方法，此方法是空实现，需要自己处理逻辑。具体逻辑是：先判断computeScrollOffset()，若为true（表示滚动未结束），则执行scrollTo()方法，它会再次调用postInvalidate()，如此反复执行，直到返回值为false。流程图如下：

  

  ![img](https:////upload-images.jianshu.io/upload_images/5494434-049e25c8dd5caa0f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

  

  其中，最重要的两个方法是startScroll()和computeScroll()

#### 55.谈一谈View的事件分发机制？

技术点：View事件分发

思路：从分发本质、传递顺序、核心方法展开

参考回答： 

- 事件分发本质：就是对**MotionEvent事件**分发的过程。即当一个MotionEvent产生了以后，系统需要将这个点击事件传递到一个具体的View上。
- 点击事件的传递顺序：**Activity（Window） -> ViewGroup -> View** 
- 三个主要方法： 
  -  **dispatchTouchEvent**：进行事件的分发（传递）。返回值是 boolean 类型，受当前onTouchEvent和下级view的dispatchTouchEvent影响
  -  **onInterceptTouchEvent**：对事件进行拦截。该方法只在ViewGroup中有，View（不包含 ViewGroup）是没有的。一旦拦截，则执行ViewGroup的onTouchEvent，在ViewGroup中处理事件，而不接着分发给View。且只调用一次，所以后面的事件都会交给ViewGroup处理。
  -  **onTouchEvent**：进行事件处理。

#### 56.如何解决View的滑动冲突？

技术点：View滑动冲突

思路：从处理规则和具体实现方法展开讨论

参考回答：

（1）处理规则： 

- 对于由于外部滑动和内部滑动**方向不一致**导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。
- 对于由于外部滑动方向和内部滑动**方向一致**导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件何时由内部View拦截事件。
- 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。

（2）实现方法： 

-  **外部拦截法**：指点击事件都先经过**父容器的拦截处理**，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的**onInterceptTouchEvent**方法，在内部做出相应的拦截。
-  **内部拦截法**：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合**requestDisallowInterceptTouchEvent**方法。

#### 57.谈一谈View的工作原理？

技术点：View工作流程

思路：围绕三大流程展开

参考回答：View工作流程简单来说就是，先measure测量，用于确定View的

测量宽高，再 layout布局，用于确定View的最终宽高和四个顶点的位置，最后 draw绘制，用于将View 绘制到屏幕上。具体过程图见：



![img](https:////upload-images.jianshu.io/upload_images/5494434-ee9e791f55a7cf6b?imageMogr2/auto-orient/strip%7CimageView2/2/w/594/format/webp)



- ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带。
- View的绘制流程是从**ViewRoot**和**performTraversals**开始。
- performTraversals()依次调用performMeasure()、performLayout()和performDraw()三个方法，分别完成**顶级** View的绘制。
- 其中，performMeasure()会调用measure()，measure()中又调用onMeasure()，实现对其所有子元素的measure过程，这样就完成了一次measure过程；接着子元素会重复父容器的measure过程，如此反复至完成整个View树的遍历。layout和draw同理。

#### 58.MeasureSpec是什么？有什么作用？

技术点：View工作流程（measure）

思路：从MeasureSpec作用、组成、模式和决定因素展开

参考回答： 

- 作用：通过宽测量值**widthMeasureSpec**和高测量值**heightMeasureSpec**决定View的大小

- 组成：一个32位int值，高2位代表**SpecMode**(测量模式)，低30位代表**SpecSize**( 某种测量模式下的规格大小)。

- 三种模式： 

  -  **UNSPECIFIED**：父容器不对View有任何限制，要多大有多大。常用于系统内部。
  -  **EXACTLY**(精确模式)：父视图为子视图指定一个确切的尺寸SpecSize。对应LyaoutParams中的**match_parent**或**具体数值**。
  -  **AT_MOST**(最大模式)：父容器为子视图指定一个最大尺寸SpecSize，View的大小不能大于这个值。对应LayoutParams中的**wrap_content**。

- 决定因素：值由子

  View的布局参数LayoutParams

  和

  父容器的MeasureSpec值

  共同决定。具体规则见下图：

  

  ![img](https:////upload-images.jianshu.io/upload_images/5494434-5729db79455bb4d2?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp)

  

引申：直接继承View的自定义View需要重写onMeasure()并设置wrap_content时的自身大小，否则效果相当于macth_parent

#### 59.自定义View/ViewGroup需要注意什么？

- 技术点：自定义View

- 参考回答：

  ![img](https://upload-images.jianshu.io/upload_images/5494434-35cc0705d2027305?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp)

#### 60.onTouch()、onTouchEvent()和onClick()关系？

技术点：View事件分发

参考回答：优先度onTouch()>onTouchEvent()>onClick()。因此onTouchListener的onTouch()方法会先触发；如果onTouch()返回false才会接着触发onTouchEvent()，同样的，内置诸如onClick()事件的实现等等都基于onTouchEvent()；如果onTouch()返回true，这些事件将不会被触发。

引申：[OnTouchListener、OnClickListener的冲突](https://www.jianshu.com/p/4b89d681c5a0)

#### 61.SurfaceView和View的区别？

技术点：View、SurfaceView

参考回答：SurfaceView是从View基类中派生出来的显示类，他和View的区别有： 

- View需要在UI线程对画面进行刷新，而SurfaceView可在子线程进行页面的刷新
- View适用于主动更新的情况，而SurfaceView适用于被动更新，如频繁刷新，这是因为如果使用View频繁刷新会阻塞主线程，导致界面卡顿
- SurfaceView在底层已实现双缓冲机制，而View没有，因此SurfaceView更适用于需要频繁刷新、刷新时数据处理量很大的页面

#### 62.invalidate()和postInvalidate()的区别？

- 技术点：View刷新
- 参考回答：invalidate()与postInvalidate()都用于刷新View，主要区别是invalidate()在主线程中调用，若在子线程中使用需要配合handler；而postInvalidate()可在子线程中直接调用。

#### 63.了解哪些Drawable？适用场景？

技术点：res资源

参考回答：BitmapDrawable表示一张图片、NinePatchDrawable可自动地根据所需的宽/高对图片进行相应的缩放并保证不失真、ShapeDrawable表示纯色、有渐变效果的基础几何图形、StateListDrawable表示一个Drawable的集合且每个Drawable对应着View的一种状态、LayerDrawable可通过将不同的Drawable放置在不同的层上面从而达到一种叠加后的效果

#### 64.mipmap系列中xxxhdpi、xxhdpi、xhdpi、hdpi、mdpi和ldpi存在怎样的关系？

- 技术点：res资源
- 参考回答：表示不同密度的图片资源，像素从高到低依次排序为xxxhdpi>xxhdpi>xhdpi>hdpi>mdpi>ldpi，根据手机的dpi不同加载不同密度的图片

#### 65.dp、dpi、px的区别？

技术点：Android适配

参考回答： 

- px：像素，如分辨率1920x1080表示高为1920个像素、宽为1080个像素
- dpi：每英寸的像素点，如分辨率为1920x1080的手机尺寸为4.95英寸，则该手机DPI为（1920x1920+ 1080x1080）½/4.95≈445dpi
- dp：密度无关像素，是个相对值

#### 66.res目录和assets目录的区别？

- 技术点：res、assets
- 参考回答：
  - res/raw中的文件会被映射到R.java文件中，访问时可直接使用资源ID，不可以有目录结构
  - assets文件夹下的文件不会被映射到R.java中，访问时需要AssetManager类，可以创建子文件夹

#### 67.Android中有哪几种类型的动画？

技术点：动画类型

参考回答： 常见三类动画 

- View动画（View Animation）/补间动画（Tween animation）：对View进行平移、缩放、旋转和透明度变化的动画，不能真正的改变view的位置。应用如布局动画、Activity切换动画
- 逐帧动画（Drawable Animation）：是View动画的一种，它会按照顺序播放一组预先定义好的图片
- 属性动画（Property Animation）：对该类对象进行动画操作，真正改变了对象的属性

#### 68.View动画和属性动画的区别？

- 技术点：View动画、属性动画
- 参考回答

![img](https://upload-images.jianshu.io/upload_images/5494434-7efd931c66573c37?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp)

#### 69.View动画为何不能真正改变View的位置？而属性动画为何可以？

- 技术点：View动画
- 参考回答：View动画改变的只是View的显示，而没有改变View的响应区域；而属性动画会通过反射技术来获取和执行属性的get、set方法，从而改变了对象位置的属性值。

#### 70.属性动画插值器和估值器的作用？

技术点：属性动画

参考回答： 

- 插值器(Interpolator)

  ：根据

  时间流逝的百分比

  计算出当前

  属性值改变的百分比

  。确定了动画效果变化的模式，如匀速变化、加速变化等等。View动画和属性动画均可使用。常用的系统内置插值器： 

  - 线性插值器(LinearInterpolator)：匀速动画
  - 加速减速插值器(AccelerateDecelerateInterpolator)：动画两头慢中间快
  - 减速插值器(DecelerateInterpolator)：动画越来越慢

- 类型估值器(TypeEvaluator)

  ：根据当前

  属性改变的百分比

  计算出

  改变后的属性值

  。针对于属性动画，View动画不需要类型估值器。常用的系统内置的估值器： 

  - 整形估值器(IntEvaluator)
  - 浮点型估值器(FloatEvaluator)
  - Color属性估值器(ArgbEvaluator)

#### 71.Activity、View、Window三者之间的关系？

技术点：Activity、View、Window联系

思路：围绕Window是Activity和View的桥梁展开

参考回答：在Activity启动过程其中的attach()方法中初始化了PhoneWindow，而PhoneWindow是Window的唯一实现类，然后Activity通过setContentView将View设置到了PhoneWindow上，而View通过WindowManager的addView()、removeView()、updateViewLayout()对View进行管理。

#### 72.Window有哪几种类型？

- 技术点：Window类型
- 参考回答：Window有三种类型：
  - **应用Window**：对应一个Activity。
  - **子Window**：不能单独存在，需附属特定的父Window。如Dialog。
  - **系统Window**： 需申明权限才能创建。如Toast。

#### 73.Activity创建和Dialog创建过程的异同？

技术点：Window创建

参考回答：

Dialog

的Window创建过程： 

- 创建WindowDialog。和Activity类似，同样是通过**PolicyManager.makeNewWindow()**  来实现。
- 初始化DecorView并将Dialog的视图添加到DecorView中去。和Activity类似，同样是通过**Window.setContentView()** 来实现。
- 将DecorView添加到Window中显示。和Activity一样，都是在自身要出现在前台时才会将添加Window。 
  -  **Dialog.show()** 方法：完成DecorView的显示。
  -  **WindowManager.remoteViewImmediate()** 方法：当Dialog被dismiss时移除DecorView。

#### 74.谈谈消息机制Hander？作用？有哪些要素？流程是怎样的？

技术点：消息机制

参考回答： 

- 作用：**跨线程通信**。当子线程中进行耗时操作后需要更新UI时，通过Handler将有关UI的操作切换到主线程中执行。

- 四要素： 

  -  **Message（消息）**：需要被传递的消息，其中包含了消息ID，消息处理对象以及处理的数据等，由MessageQueue统一列队，最终由Handler处理。
  -  **MessageQueue（消息队列）**：用来存放Handler发送过来的消息，内部通过**单链表**的数据结构来维护消息列表，等待Looper的抽取。
  -  **Handler（处理者）**：负责Message的发送及处理。通过 Handler.sendMessage() 向消息池发送各种消息事件；通过 Handler.handleMessage() 处理相应的消息事件。
  -  **Looper（消息泵）**：通过Looper.loop()不断地从MessageQueue中抽取Message，按分发机制将消息分发给目标处理者。

- 具体流程如图

  

  ![img](https:////upload-images.jianshu.io/upload_images/5494434-83abcea8a9b400aa?imageMogr2/auto-orient/strip%7CimageView2/2/w/725/format/webp)

  

  -  `Handler.sendMessage()`发送消息时，会通过`MessageQueue.enqueueMessage()`向MessageQueue中添加一条消息；
  - 通过`Looper.loop()`开启循环后，不断轮询调用`MessageQueue.next()`；
  - 调用目标`Handler.dispatchMessage()`去传递消息，目标Handler收到消息后调用`Handler.handlerMessage()`处理消息。

#### 75.为什么系统不建议在子线程访问UI？

- 技术点：UI线程、子线程

- 参考回答：系统不建议在子线程访问UI的原因是，UI控件

  非线程安全

  ，在多线程中并发访问可能会导致UI控件处于不可预期的状态。而不对UI控件的访问加上锁机制的原因有：

  - 上锁会让UI控件变得复杂和低效
  - 上锁后会阻塞某些进程的执行

#### 76.一个Thread可以有几个Looper？几个Handler？

技术点：Looper、Handler

参考回答：一个Thread只能有一个Looper，可以有多个Handler

引申：更多数量关系：Looper有一个MessageQueue，可以处理来自多个Handler的Message；MessageQueue有一组待处理的Message，这些Message可来自不同的Handler；Message中记录了负责发送和处理消息的Handler；Handler中有Looper和MessageQueue；

#### 77.如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？

- 技术点：Looper
- 参考回答：通过Looper.prepare()可将一个Thread线程转换成Looper线程。Looper线程和普通Thread不同，它通过MessageQueue来存放消息和事件、Looper.loop()进行消息轮询。

#### 78.可以在子线程直接new一个Handler吗？那该怎么做？

- 技术点：Handler
- 参考回答：不同于主线程直接new一个Handler，由于子线程的Looper需要手动去创建，在创建Handler时需要多一些方法：

#### 79.Message可以如何创建？哪种效果更好，为什么？

技术点：Message

参考回答：创建Message对象的几种方式： 

- Message msg = new Message();
- Message msg = Message.obtain();
- Message msg = handler1.obtainMessage();
   后两种方法都是从整个Messge池中返回一个新的Message实例，能有效避免重复Message创建对象，因此更鼓励这种方式创建Message

#### 80.这里的ThreadLocal有什么作用？

技术点：ThreadLocal

参考回答：ThreadLocal类可实现线程本地存储的功能，把共享数据的可见范围限制在同一个线程之内，无须同步就能保证线程之间不出现数据争用的问题，这里可理解为ThreadLocal帮助Handler找到本线程的Looper。 

- 底层数据结构：每个线程的Thread对象中都有一个ThreadLocalMap对象，它存储了一组以ThreadLocal.threadLocalHashCode为key、以本地线程变量为value的键值对，而ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，也就包含了一个独一无二的threadLocalHashCode值，通过这个值就可以在线程键值值对中找回对应的本地线程变量。

#### 81.主线程中Looper的轮询死循环为何没有阻塞主线程？

技术点：Looper

参考回答：Android是依靠事件驱动的，通过Loop.loop()不断进行消息循环，可以说Activity的生命周期都是运行在 Looper.loop()的控制之下，一旦退出消息循环，应用也就退出了。而所谓的导致ANR多是因为某个事件在主线程中处理时间太耗时，因此只能说是对某个消息的处理阻塞了Looper.loop()，反之则不然。

#### 82.使用Hanlder的postDealy()后消息队列会发生什么变化？

技术点：Handler

参考回答：post delay的Message并不是先等待一定时间再放入到MessageQueue中，而是直接进入并阻塞当前线程，然后将其delay的时间和队头的进行比较，按照触发时间进行排序，如果触发时间更近则放入队头，保证队头的时间最小、队尾的时间最大。此时，如果队头的Message正是被delay的，则将当前线程堵塞一段时间，直到等待足够时间再唤醒执行该Message，否则唤醒后直接执行。

#### 83.Android中还了解哪些方便线程切换的类？

技术点：线程通信

参考回答：对Handler进一步的封装的几个类： 

-  **AsyncTask**：底层封装了线程池和**Handler**，便于执行后台任务以及在子线程中进行UI操作。
-  **HandlerThread**：一种具有**消息循环**的线程，其内部可使用Handler。
-  **IntentService**：是一种**异步、会自动停止**的服务，内部采用HandlerThread。

引申：更多是对消息机制的理解

#### 84.AsyncTask相比Handler有什么优点？不足呢？

技术点：AsyncTask、Handler

参考回答： 

- Handler机制存在的**问题**：多任务同时执行时不易精确控制线程。
- 引入AsyncTask的**好处**：创建异步任务更简单，直接继承它可方便实现后台异步任务的执行和进度的回调更新UI，而无需编写任务线程和Handler实例就能完成相同的任务。

#### 85.使用AsyncTask需要注意什么？

技术点：AsyncTask

参考回答： 

- 不要直接调用onPreExecute()、doInBackground()、onProgressUpdate()、onPostExecute()和onCancelled()方法
- 一个异步对象只能调用一次execute()方法

引申：谈谈AsyncTask初始化、五个核心方法如何配合进而体现Handler的作用

#### 86.AsyncTask中使用的线程池大小？

技术点：AsyncTask

参考回答：在AsyncTask内部实现有两个线程池： 

-  **SerialExecutor**：用于任务的排队，默认是**串行**的线程池，在3.0以前核心线程数为5、线程池大小为128，而3.0以后变为同一时间只能处理一个任务
-  **THREAD_POOL_EXECUTOR**：用于真正执行任务。

引申：谈谈对线程池的理解

#### 87.HandlerThread有什么特点？

技术点：HandlerThread

参考回答：HandlerThread是一个线程类，它继承自Thread。与普通Thread不同，HandlerThread具有**消息循环**的效果，这是因为它内部`HandlerThread.run()`方法中有Looper，能通过`Looper.prepare()`来创建消息队列，并通过`Looper.loop()`来开启消息循环。

#### 88.快速实现子线程使用Handler

技术点：HandlerThread

思路：不同于之前手动在子线程创建Looper再构建Handler的想法，这里从HandlerThread角度去快速实现在子线程使用Handler

参考回答：HandlerThread实现方法 

- 实例化一个HandlerThread对象，参数是该线程的名称；
- 通过 HandlerThread.start()开启线程；
- 实例化一个Handler并传入HandlerThread中的looper对象，使得与HandlerThread绑定；
- 利用Handler即可执行异步任务；
- 当不需要HandlerThread时，通过HandlerThread.quit()/quitSafely()方法来终止线程的执行。

#### 89.IntentService的特点？

技术点：IntentService

思路：和普通线程和普通Service比较突出其特点

参考回答： 不同于线程，IntentService是服务，优先级比线程高，更不容易被系统杀死，因此较适合执行一些**高优先级**的后台任务；不同于普通Service，IntentService可**自动创建**子线程来执行任务，且任务执行完毕后**自动退出**。

#### 90.为何不用bindService方式创建IntentService？

技术点：IntentService

思路：从底层实现出发

参考回答：IntentService的工作原理是，在IntentService的onCreate()里会创建一个HandlerThread，并利用其内部的Looper实例化一个ServiceHandler对象；而这个ServiceHandler用于处理消息的handleMessage()方法会去调用IntentService的onHandleIntent()，这也是为什么可在该方法中处理后台任务的逻辑；当有Intent任务请求时会把Intent封装到Message，然后ServiceHandler会把消息发送出，而发送消息是在onStartCommand()完成的，只能通过startService()才可走该生命周期方法，因此不能通过bindService创建IntentService。

#### 91.线程池的好处、原理、类型？

技术点：线程池

参考回答：

（1）线程池的好处： 

-  **重用**线程池中的线程，避免线程的创建和销毁带来的性能消耗；
- 有效控制线程池的**最大并发数**，避免大量的线程之间因互相抢占系统资源而导致阻塞现象；
- 进行**线程管理**，提供定时/循环间隔执行等功能

（2）线程池的分类： 

-  **FixThreadPool**：线程数量固定的线程池，所有线程都是**核心线程**，当线程空闲时**不会**被回收；能**快速**响应外界请求。
-  **CachedThreadPool**：线程数量不定的线程池（最大线程数为**Integer.MAX_VALUE**），只有**非核心线程**，空闲线程有超时机制，超时回收；适合于执行大量的**耗时较少**的任务
-  **ScheduledThreadPool**：核心线程数量**固定**，非核心线程数量**不定**；可进行**定时**任务和**固定**周期的任务。
-  **SingleThreadExecutor**：只有**一个核心线程**，可确保所有的任务都在同一个线程中**按顺序**执行；好处是无需处理**线程同步**问题。

（3）线程池的原理：实际上通过ThreadPoolExecutor并通过一系列参数来配置各种各样的线程池，具体的参数有： 

-  **corePoolSize**核心线程数：一般会在线程中一直存活
-  **maximumPoolSize**最大线程数：当活动线程数达到这个数值后，后续的任务将会被阻塞
-  **keepAliveTime**非核心线程超时时间：超过这个时长，闲置的非核心线程就会被回收
-  **unit**：用于指定keepAliveTime参数的时间单位
-  **workQueue**任务队列：通过线程池的`execute()`方法提交的Runnable对象会存储在这个参数中。
-  **threadFactory**：线程工厂，可创建新线程
-  **handler**：在线程池无法执行新任务时进行调度

引申：[使用Executors各个方法创建线程池的弊端](https://www.jianshu.com/p/4b89d681c5a0)

#### 92.ThreadPoolExecutor的工作策略？

技术点：线程池

参考回答：ThreadPoolExecutor的

默认工作策略

： 

- 若程池中的线程数量**未达到**核心线程数，则会直接启动一个核心线程执行任务。

- 若线程池中的线程数量

  已达到

  或者超过核心线程数量，则任务会被插入到任务列表等待执行。 

  - 若任务

    无法插入

    到任务列表中，往往由于任务列表已满，此时如果 

    - 线程数量**未达到**线程池最大线程数，则会启动一个非核心线程执行任务；
    - 线程数量**已达到**线程池规定的最大值，则拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。

引申：ThreadPoolExecutor的拒绝策略

#### 93.什么是ANR？什么情况会出现ANR？如何避免？在不看代码的情况下如何快速定位出现ANR问题所在？

技术点：ANR

思路：

参考回答： 

- ANR（Application Not Responding，应用无响应）：当操作在一段时间内系统无法处理时，会在系统层面会弹出ANR对话框
- 产生ANR可能是因为5s内无响应用户输入事件、10s内未结束BroadcastReceiver、20s内未结束Service
- 想要避免ANR就不要在主线程做耗时操作，而是通过开子线程，方法比如继承Thread或实现Runnable接口、使用AsyncTask、IntentService、HandlerThread等

引申：快读定位ANR方法：使用命令导出ANR日志，并分析关键信息，详见[如何分析ANR](https://www.jianshu.com/p/cfa9ed42e379)

#### 94.加载图片的时候需要注意什么？

技术点：Bitmap高效加载

参考回答： 

- 直接加载大容量的高清Bitmap很容易出现显示不完整、内存溢出OOM的问题，所以最好按一定的**采样率**将图片缩小后再加载进来
- 为减少流量消耗，可对图片采用内存缓存策略，又为了避免图片占用过多内存导致内存溢出，最好以软引用方式持有图片
- 如果还需要网上下载图片，注意要开子线程去做下载的耗时操作

#### 95.LRU算法的原理？

技术点：LRU算法

参考回答：为减少流量消耗，可采用缓存策略。常用的缓存算法是LRU(Least Recently Used)： 

- 核心思想：当缓存满时, 会优先淘汰那些近期最少使用的缓存对象。主要是两种方式： 
  - LruCache(内存缓存)：LruCache类是一个线程安全的**泛型类**：内部采用一个`LinkedHashMap`以**强引用**的方式存储外界的缓存对象，并提供`get`和`put`方法来完成缓存的获取和添加操作，当缓存满时会移除较早使用的缓存对象，再添加新的缓存对象。
  - DiskLruCache(磁盘缓存)： 通过将缓存对象**写入文件**系统从而实现缓存效果

引申：感兴趣可了解具体实现算法

#### 96.项目中如何做性能优化的？

- 技术点：性能优化实例
- 思路：举例说明项目注意了哪些方面的性能优化，如布局优化、绘制优化、内存泄漏优化、 响应速度优化、列表优化、Bitmap优化、 线程优化......

#### 97.布局上如何优化？

技术点：布局优化

参考回答：布局优化的核心就是尽量减少布局文件的

层级

，常见的方式有： 

- 多嵌套情况下可使用RelativeLayout减少嵌套。
- 布局层级相同的情况下使用LinearLayout，它比RelativeLayout更高效。
- 使用`<include>`标签重用布局、`<merge>`标签减少层级、`<ViewStub>`标签懒加载。

#### 98.内存泄漏是什么？为什么会发生？常见哪些内存泄漏的例子？都是怎么解决的？

技术点：内存泄漏

参考回答：内存泄漏(Memory Leak)是指程序在申请内存后，

无法释放

已申请的内存空间。简单地说，发生内存泄漏是由于长周期对象持有对短周期对象的引用，使得短周期对象不能被及时回收。常见的几个例子和解决办法： 

- 单例模式导致的内存泄漏：单例传入参数this来自Activity，使得持有对Activity的引用。 

  - 解决办法：传参context.getApplicationContext()

- Handler导致的内存泄漏：Message持有对Handler的引用，而非静态内部类的Handler又隐式持有对外部类Activity的引用，使得引用关系会保持至消息得到处理，从而阻止了Activity的回收。 

  - 解决办法：使用静态内部类+WeakReference弱引用；当外部类结束生命周期时清空消息队列。

- 线程导致的内存泄漏：AsyncTask/Runnable以

  匿名内部类

  的方式存在，会隐式持有对所在Activity的引用。 

  - 解决办法：将AsyncTask和Runnable设为静态内部类或独立出来；在线程内部采用弱引用保存Context引用

- 资源未关闭导致的内存泄漏：未及时注销资源导致内存泄漏，如BraodcastReceiver、File、Cursor、Stream、Bitmap等。 

  - 解决办法：在Activity销毁的时候要及时关闭或者注销。 
    - BraodcastReceiver：调用`unregisterReceiver()`注销；
    - Cursor，Stream、File：调用`close()`关闭；
    - 动画：在`Activity.onDestroy()`中调用`Animator.cancel()`停止动画

引申：谈谈项目中是如何注意内存泄漏的问题

#### 99.内存泄漏和内存溢出的区别

- 技术点：内存泄漏、内存溢出
- 参考回答：
  - 内存泄漏(Memory Leak)是指程序在申请内存后，**无法释放**已申请的内存空间。是造成应用程序OOM的主要原因之一。
  - 内存溢出(out of memory)是指程序在申请内存时，没有足够的内存空间供其使用。

#### 100.什么情况会导致内存溢出？

- 技术点：内存溢出
- 参考回答：内存泄漏是导致内存溢出的主要原因；直接加载大图片也易造成内存溢出
- 引申：谈谈如何避免内存溢出（如何避免内存泄漏、避免直接加载大图片）

#### 101.面向对象编程的四大特性及其含义？

技术点：面向对象编程特点

思路：分条简述每个特性的含义

参考回答： 

- 抽象：对现实世界的事物进行概括，抽象为在计算机虚拟世界中有意义的实体
- 封装：将某事物的属性和行为包装到对象中，构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，并且尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系
- 继承：子类继承父类，不仅可以有父类原有的方法和属性，也可以增加自己的或者重写父类的方法及属性
- 多态：允许不同类的对象对同一消息做出各自的响应。

#### 102.String、StringBuffer和StringBuilder的区别？

技术点：String

参考回答： 

- String是字符串常量，而StringBuffer、StringBuilder都是字符串变量，即String对象一创建后不可更改，而后两者的对象是可更改的：
- StringBuffer是线程安全的，而StringBuilder是非线程安全的，这是由于StringBuffer对方法加了同步锁或者对调用的方法加了同步锁
- String更适用于少量的字符串操作的情况，StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况，StringBuffer适用于多线程下在字符缓冲区进行大量操作的情况

#### 103.String a=""和String a=new String("")的的关系和异同？

技术点：String

参考回答： 

- 通过String a=""直接赋值的方式得到的是一个字符串常量，存在于常量池；注意，相同内容的字符串在常量池中只有一个，即如果池已包含内容相等的字符串会返回池中的字符串，反之会将该字符串放入池中
- 通过new String("")创建的字符串不是常量是实例对象，会在堆内存开辟空间并存放数据，且每个实例对象都有自己的地址空间

引申：对于用String a=""和String a=new String("")两种方式定义的字符串，判断使用equals()、"=="比较结果是什么

#### 104.Object的equal()和==的区别？

技术点：equal()、==

参考回答： 

- equals()：是Object的公有方法，具体含义取决于如何重写，比如String的equals()比较的是两个字符串的内容是否相同
- "==" ：对于基本数据类型来说，比较的是两个变量值是够是否相等，对于引用类型来说，比较的是两个对象的内存地址是否相同

引申：对于用String a=""和String a=new String("")两种方式定义的字符串，判断使用equals()、"=="比较结果是什么

#### 105.装箱、拆箱什么含义？

- 技术点：装箱、拆箱
- 参考回答：装箱就是自动将基本数据类型转换为包装器类型，拆箱就是自动将包装器类型转换为基本数据类型

#### 106.int和Integer的区别？

技术点：基本数据类型、引用类型

参考回答： 

- Integer是int的包装类，int则是java的一种基本数据类型
- Integer变量必须实例化后才能使用，而int变量不需要
- Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值
- Integer的默认值是null，int的默认值是0

#### 107.遇见过哪些运行时异常？异常处理机制知道哪些？

技术点：Java异常机制

思路：对Throwable异常进行分类说明每种异常的特点和常见问题，简述几种常见异常处理机制，详见[Java基础之异常机制](https://www.jianshu.com/p/3718766df5ba) 

参考回答：

（1） Throwable继承层次结构，可见分成两大类Error和Exception： 

- Error（错误）:指程序**无法**恢复的异常情况，表示运行应用程序中较严重的问题；发生于虚拟机自身、或者在虚拟机试图执行应用时，如Virtual MachineError（Java虚拟机运行错误）、NoClassDefFoundError（类定义错误）；属于**不可查**异常，即不强制程序员必须处理，即使不处理也不会出现语法错误。

- Exception（异常）:指程序

  有可能

  恢复的异常情况，表示程序本身可以处理的异常。又分两大类： 

  - RuntimeException（运行时异常）：由程序**自身**的问题导致产生的异常；如NullPointerException（空指针异常）、IndexOutOfBoundsException（下标越界异常）；属于**不可查**异常。

  - 非运行时异常：由程序

    外部

    的问题引起的异常；除了RuntimeException以外的异常，如FileNotFoundException（文件不存在异常）；属于

    可查

    异常，即强制程序员必须进行处理，如果不进行处理则会出现语法错误。

    

    ![img](https:////upload-images.jianshu.io/upload_images/5494434-f238ec7504cec330?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

    

（2）常见的异常处理机制有： 

- 捕捉异常：由系统自动抛出异常，即try捕获异常->catch处理异常->finally 最终处理
- 抛出异常：在方法中将异常对象**显性**地抛出，之后异常会沿着调用层次向上抛出，交由调用它的方法来处理。配合throws声明抛出的异常和throw抛出异常
- 自定义异常：继承Execption类或其子类

#### 108.什么是反射，有什么作用和应用？

技术点：反射

思路：简述反射的定义、功能和应用，详见[Java基础之泛型&反射](https://www.jianshu.com/p/fcdfb8234b66) 

参考回答： 

-  **含义**：在运行状态中，对于任意一个类都能知道它的所有属性和方法，对于任何一个对象都能够调用它的任何一个方法和属性。
-  **功能**：动态性，体现在：在运行时判断任意一个类所具有的属性和方法； 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时调用任意一个对象的方法；生成动态代理
- 应用：反射&泛型

引申：是否在项目中使用过反射机制，有什么优缺点

#### 109.什么是内部类？有什么作用？静态内部类和非静态内部类的区别？

技术点：内部类

思路：

参考回答：内部类就是定义在另外一个类里面的类。它隐藏在外部类中，封装性更强，不允许除外部类外的其他类访问它；但它可直接访问外部类的成员。静态内部类和非静态内部类的区别有： 

- 静态内部类是指被声明为static的内部类，可不依赖外部类实例化；而非静态内部类需要通过生成外部类来间接生成。
- 静态内部类只能访问外部类的静态成员变量和静态方法，而非静态内部类由于持有对外部类的引用，可以访问外部类的所用成员

引申：谈谈匿名内部类

#### 110.final、finally、finalize()分别表示什么含义

技术点：final、finally、finalize()

参考回答： 

- final关键字表示不可更改，具体体现在： 
  - final修饰的变量必须要初始化，且赋初值后不能再重新赋值
  - final修饰的方法不能被子类重写
  - final修饰的类不能被继承
- finally：和try、catch成套使用进行异常处理，无论是否捕获或处理异常，finally块里的语句都会被执行，在以下4种特殊情况下，finally块才不会被执行： 
  - 在finally语句块中发生了异常
  - 在前面的代码中用了`System.exit()`退出程序
  - 程序所在的线程死亡
  - 关闭CPU
- finalize()：是Object中的方法，当垃圾回收器将回收对象从内存中清除出去之前会调用finalize()，但此时并不代表该回收对象一定会“死亡”，还有机会“逃脱”

#### 111.重写和重载的区别？

- 技术点：重写、重载
- 参考回答：重写表示子类重写父类的方法；重载表示有多个同名函数同时存在，区别在于有不同的参数个数或类型
- 引申：谈谈动态分派和静态分派

#### 112.抽象类和接口的异同？

- 技术点：抽象类、接口
- 参考回答：
  - 使用上的区别：一个类只能继承一个抽象类却可以实现多个接口
  - 设计上的区别：接口是对行为的抽象，无需有子类的前提，是自上而下的设计理念；抽象类是对类的抽象，建立于相似子类之上，是自下而上的设计理念

#### 113.为什么匿名内部类中使用局部变量要用final修饰？

- 技术点：匿名内部类
- 参考回答：一方面，由于方法中的局部变量的生命周期很短，一旦方法结束变量就要被销毁，为了保证在内部类中能找到外部局部变量，通过final关键字可得到一个外部变量的引用；另一方面，通过final关键字也不会在内部类去做修改该变量的值，保护了数据的一致性.

#### 114.Java集合框架中有哪些类？都有什么特点

技术点：集合框架

思路：分条解释每种类的特点

参考回答：可将Java集合框架大致可分为Set、List、Queue 和Map四种体系 

- Set：代表**无序、不可重复**的集合，常见的类如HashSet、TreeSet
- List：代表**有序、可重复**的集合，常见的类如动态数组ArrayList、双向链表LinkedList、可变数组Vector
- Map：代表具有**映射关系**的集合，常见的类如HashMap、LinkedHashMap、TreeMap
- Queue：代表一种**队列**集合

#### 115.集合、数组、泛型的关系，并比较

技术点：集合、数组、泛型

参考回答：

（1）集合和数组的区别： 

- 数组元素可以是基本类型，也可以是对象；数组长度限定；数组只能存储一种类型的数据元素
- 集合元素只能是对象；集合长度可变；集合可存储不同种的数据元素

（2）泛型相比与集合的好处在于它**安全简单**。具体体现在提供编译时的强类型检查，而不用等到运行；可避免类类型强制转换

#### 116.ArrayList和LinkList的区别？

- 技术点：List对比
- 参考回答：
  - **ArrayList**的底层结构是**数组**，可用索引实现快速查找；是动态数组，相比于数组容量可实现动态增长
  - **LinkedList**底层结构是**链表**，增删速度快；是一个**双向循环**链表，也可以被当作堆栈、队列或双端队列

#### 117.ArrayList和Vector的区别？

技术点：List对比

参考回答： 

-  **ArrayList**非线程安全，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList；默认初始容量为10，每次扩容为原来的1.5倍
-  **Vector**使用了synchronized关键字，是**线程安全**的，比ArrayList开销更大，访问更慢；默认初始容量为10，默认每次扩容为原来的2倍，可通过**capacityIncrement**属性设置

#### 118.HashSet和TreeSet的区别？

技术点：Set对比

参考回答： 

-  **HashSet**不能保证元素的排列顺序；使用**Hash算法**来存储集合中的元素，有良好的存取和查找性能；通过`equal()`判断两个元素是否相等，并两个元素的`hashCode()`返回值也相等
-  **TreeSet**是SortedSet接口的实现类，根据元素**实际值的大小**进行排序；采用**红黑树**的数据结构来存储集合元素；支持两种排序方法：**自然排序**（默认情况）和**定制排序**。前者通过实现**Comparable接口**中的`compareTo()`比较两个元素之间大小关系，然后按升序排列；后者通过实现**Comparator接口**中的`compare()`比较两个元素之间大小关系，实现定制排列。

#### 119.HashMap和Hashtable的区别？

技术点：Map对比

参考回答： 

-  **HashMap**基于AbstractMap类，实现了Map、**Cloneable**（能被克隆）、**Serializable**（支持序列化）接口； **非线程安全**；允许存在一个为null的key和任意个为null的value；采用**链表散列**的数据结构，即数组和链表的结合；初始容量为16，填充因子默认为0.75，扩容时是当前容量翻倍，即2capacity
-  **Hashtable**基于Map接口和Dictionary类；**线程安全**，开销比HashMap大，如果多线程访问一个Map对象，使用Hashtable更好；不允许使用null作为key和value；底层基于哈希表结构；初始容量为11，填充因子默认为0.75，扩容时是容量翻倍+1，即2capacity+1

#### 120.HashMap在put、get元素的过程？体现了什么数据结构？

技术点：HashMap

参考回答： 

- 向Hashmap中put元素时，首先判断key是否为空，为空则直接调用putForNullKey()，不为空则计算key的hash值得到该元素在数组中的下标值；如果数组在该位置处没有元素，就直接保存；如果有，还要比较是否存在相同的key，存在的话就覆盖原来key的value，否则将该元素保存在链头，先保存的在链尾。
- 从Hashmap中get元素时，计算key的hash值找到在数组中的对应的下标值，返回该key对应的value即可，如果有冲突就遍历该位置链表寻找key相同的元素并返回对应的value
- 由此可看出HashMap采用**链表散列**的数据结构，即数组和链表的结合，在Java8后又结合了红黑树，当链表元素超过8个将链表转换为红黑树

#### 121.如何解决Hash冲突？

技术点：Hash冲突

参考回答： 

- 开放定址法：常见的线性探测方式，在冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表
- 链地址法：将有冲突数组位置生出链表
- 建立公共溢出区：将哈希表分为基本表和溢出表两部分，和基本表发生冲突的元素一律填入溢出表
- 再哈希法：构造多个不同的哈希函数，有冲突使用下一个哈希函数计算hash值。

#### 122.如何保证HashMap线程安全？什么原理？

技术点：ConcurrentHashMap

思路：这里回答一种办法，使用ConcurrentHashMap

参考回答：ConcurrentHashMap是线程安全的HashMap，它采取锁分段技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。在JDK1.8中对ConcurrentHashmap做了两个改进： 

- 取消segments字段，直接采用`transient volatile HashEntry<K,V>[] table`保存数据，将数组元素作为锁，对每一行数据进行加锁，可减少并发冲突的概率
- 数据结构由“数组＋单向链表”变为“数组＋单向链表＋红黑树”，使得查询的时间复杂度可以降低到O(logN)，改进一定的性能。

引申：LinkHashMap线程安全的底层实现

#### 123.HashMap是有序的吗？如何实现有序？

技术点：LinkHashMap

思路：这里回答一种办法，使用LinkedHashMap

参考回答：HashMap是无序的，而LinkedHashMap是有序的HashMap，默认为插入顺序，还可以是访问顺序，基本原理是其内部通过Entry维护了一个双向链表，负责维护Map的迭代顺序

引申：LinkHashMap有序的底层实现

#### 124.HashMap是如何扩容的？如何避免扩容？

技术点：HashMap

参考回答： 

- HashMap几个默认值，初始容量为16、填充因子默认为0.75、扩容时容量翻倍。也就是说当HashMap中元素个数超过`16*0.75=12`时会把数组的大小扩展为`2*16=32`，然后重新计算每个元素在数组中的位置
- 由于每次扩容还需要重新计算元素Hash值，损耗性能，所以建议在使用HashMap时，最好先估算Map的大小，设置初始值，避免频繁扩容

#### 125.hashcode()的作用，与equal()有什么区别？

技术点：Hash值

参考回答：hashCode()用于计算对象的Hash值，确认对象在散列存储结构中的存储地址。和equal()的区别： 

- equals()比较两个对象的地址值是否相等 ；hashCode()得到的是对象的存储位置，可能不同对象会得到相同值
- 有两个对象，若equals()相等，则hashcode()一定相等；hashcode()不等，则equals()一定不相等；hashcode()相等，equals()可能相等、可能不等
- 使用equals()比较两个对象是否相等效率较低，最快办法是先用hashCode()比较，如果hashCode()不相等，则这两个对象肯定不相等；如果hashCode()相等，此时再用equal()比较，如果equal()也相等，则这两个对象的确相等，反之

#### 126.同步和非同步、阻塞和非阻塞的概念

技术点：同步、阻塞

参考回答： 

- 同步和异步体现的是消息的通知机制：所谓同步，方法A调用方法B后必须等到方法B返回结果才能继续后面的操作；所谓异步，方法A调用方法B后可让方法B在调用结束后通过回调等方式通知方法A
- 阻塞和非阻塞侧重于等待消息时的状态：所谓阻塞，就是在结果返回之前让当前线程挂起；所谓非阻塞，就是在等待时可做其他事情，通过轮询去询问是否已返回结果

#### 127.Thread的join()有什么作用？

- 技术点：线程相关方法
- 参考回答：Thread的join()的含义是等待该线程终止，即将挂起调用线程的执行，直到被调用的对象完成它的执行。比如存在两个线程t1和t2，下述代码表示先启动t1，直到t1的任务结束，才轮到t2启动。

#### 128.线程的有哪些状态？

技术点：线程状态

思路：可分条解释每种状态的特点以及如何转换。详见[要点提炼| 理解JVM之内存模型&线程](https://www.jianshu.com/p/90a036212cb4) 

参考回答：在任意一个时间点，一个线程只能有且只有其中的一种状态： 

-  **新建**（New）：线程创建后尚未启动

-  **运行**（Runable）：包括正在执行（Running）和等待着CPU为它分配执行时间（Ready）两种

- 无限期等待

  （Waiting）：该线程不会被分配CPU执行时间，要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期等待状态： 

  - 没有设置Timeout参数的`Object.wait()` 
  - 没有设置Timeout参数的`Thread.join()` 
  - `LockSupport.park()`

- 限期等待

  （Timed Waiting）：该线程不会被分配CPU执行时间，但在一定时间后会被系统自动唤醒。以下方法会让线程进入限期等待状态： 

  - `Thread.sleep()`
  - 设置了Timeout参数的`Object.wai()` 
  - 设置了Timeout参数的`Thread.join()` 
  - `LockSupport.parkNanos()`
  - `LockSupport.parkUntil()`

-  **阻塞**（Blocked）：线程被阻塞。和等待状态不同的是，阻塞状态表示在等待获取到一个**排他锁**，在另外一个线程放弃这个锁的时候发生；而等待状态表示在等待一段**时间**或者**唤醒动作**的发生，在程序等待进入同步区域的时候发生。

- 结束

  （Terminated）：线程已经结束执行

  

  ![img](https:////upload-images.jianshu.io/upload_images/5494434-9685e1eb1b755843.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp)

#### 129.什么是线程安全？保障线程安全有哪些手段？

技术点：线程安全

思路：详见[要点提炼| 理解JVM之线程安全&锁优化](https://www.jianshu.com/p/ca8801044352) 

参考回答：线程安全就是当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。保证线程安全可从多线程三特性出发： 

- 原子性

  （Atomicity）：单个或多个操作是要么全部执行，要么都不执行 

  - Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码
  - synchronized：对线程加独占锁，被它修饰的类/方法/变量只允许一个线程访问

- 可见性

  （Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改 

  - volatile：保证新值能**立即**同步到主内存，且每次使用前立即从主内存刷新；
  - synchronized：在释放锁之前会将工作内存新值更新到主存中

- 有序性

  （Ordering）：程序代码按照指令顺序执行 

  - volatile： 本身就包含了禁止指令重排序的语义
  - synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入

#### 130.ReentrantLock和synchronized的区别?

技术点：线程安全（ReentrantLock、synchronized）

思路：详见[要点提炼| 理解JVM之线程安全&锁优化](https://www.jianshu.com/p/ca8801044352) 

参考回答： ReentrantLock与synchronized的

不同

在于ReentrantLock： 

-  **等待可中断**：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
-  **公平锁**：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。而synchronized是非公平的，即在锁被释放时，任何一个等待锁的线程都有机会获得锁。ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数改用公平锁。
-  **锁绑定多个条件**：一个ReentrantLock对象可以通过多次调用newCondition()同时绑定多个Condition对象。而在synchronized中，锁对象wait()和notify()或notifyAl()只能实现一个隐含的条件，若要和多于一个的条件关联不得不额外地添加一个锁。

#### 131.synchronized和volatile的区别？

技术点：线程安全（synchronized、volatile）

参考回答： 

- synchronized能保证操作的原子性，而[volatile不可以](https://www.cnblogs.com/kubidemanong/p/9505944.html)，假设线程A和线程B同时读取到变量a值，A修改a后将值更新到主内存，同时B也修改a值会覆盖A的修改操作
- synchronized可修饰变量、方法和类，而volatile只能修饰变量
- synchronized可能会造成线程阻塞，而volatile不会造成线程的阻塞

#### 132.synchronized同步代码块还有同步方法本质上锁住的是谁？为什么？

技术点：线程安全（synchronized）

参考回答：本质上锁住的是对象。在java虚拟机中，每个对象和类在逻辑上都和一个监视器相关联，synchronized本质上是对一个对象监视器的获取。当执行同步代码块或同步方法时，执行方法的线程必须先获得该对象的监视器，才能进入同步代码块或同步方法；而没有获取到的线程将会进入阻塞队列，直到成功获取对象监视器的线程执行结束并释放锁后，才会唤醒阻塞队列的线程，使其重新尝试对对象监视器的获取。

#### 133.sleep()和wait()的区别？

技术点：sleep()、wait()

参考回答： 

- sleep()来自Thread类；wait()来自Object类
- sleep()用于线程控制自身流程；而wait()用于线程间通信，配合notify()/notifyAll()在同步代码块或同步方法里使用
- sleep()的线程不会释放对象锁；wait()会释放对象锁进入等待状态，使得其他线程能使用同步代码块或同步方法

#### 134.怎么理解数据结构？

技术点：数据结构

思路：数据结构的定义、分类

参考回答：研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型。 

- 按照逻辑结构分类 
  - 线性结构：线性表、栈、队列
  - 非线性结构：树、图
- 按照存储结构分为顺序结构、链式结构、索引结构、哈希结构

#### 135.什么是斐波那契数列？

技术点：递归和循环

思路：斐波那契数列的定义

参考回答：斐波那契数列指的是这样的数列1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...即这个数列从第3项开始，每一项都等于前两项之和，数学表示F(1)=1，F(2)=1, F(3)=2,F(n)=F(n-1)+F(n-2)（n>=4，n∈N*）

#### 136.迭代和递归的特点，并比较优缺点

> - 技术点：递归和循环
> - 参考回答：递归和迭代都是循环的一种，特点： 
>   - 递归就是通过重复调用函数自身实现循环；满足终止条件时会逐层返回来结束循环
>   - 迭代通过函数内某段代码实现循环；使用计数器结束循环

|      | 优点                         | 缺点                                                         |
| ---- | ---------------------------- | ------------------------------------------------------------ |
| 递归 | 代码更简洁清晰，可读性更好   | 需要调用函数，会造成空间的浪费；使用栈机制，循环次数太多易造成堆栈溢出 |
| 迭代 | 效率高；无额外开销，节省空间 | 代码不如递归简洁                                             |

#### 137.了解哪些查找算法，时间复杂度都是多少？

> - 技术点：查找
> - 参考回答：代码详见[java实现常见查找算法](https://blog.csdn.net/smile_from_2015/article/details/72190562) 

| 名称         | 类型           | 特点                                                         | 时间复杂度            | 适用                         |
| ------------ | -------------- | ------------------------------------------------------------ | --------------------- | ---------------------------- |
| 顺序查找     | 静态查找表     | 从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比较 | O(n)                  | 无序表                       |
| 有序查找     | 静态查找表     | 根据分隔点的选择不同分以下三种查找方法：                     | O(logn)               | 有序表                       |
|              | 1.二分查找     | 取中间值为比较对象，若等于关键字，则查找成功；若大于关键字，则在比较对象的左半区继续查找；若小于关键字，则在比较对象的右半区继续查找。不断重复上述过程直到查找成功，若所有查找区域无记录则查找失败 |                       |                              |
|              | 2.插值查找     | 是根据要查找的关键字与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low) |                       | 表长较大而关键字分布比较均匀 |
|              | 3.斐波那契查找 | 在二分查找的基础上根据斐波那契数列进行分割的                 |                       |                              |
| 线性索引查找 | 静态查找表     | 引入索引并将索引项集合组织为线性结构，常用的三种线性索引技术： |                       | 数据量极大并按照先后顺序存储 |
|              | 1.稠密索引     | 数据集中的每个记录都对应一个索引项，且索引项按照关键码进行有序排列 |                       |                              |
|              | 2.分块索引     | 是把数据集的记录分成了若干块，块内无序、块间有序             |                       |                              |
|              | 3.倒排索引     | 不是由记录来确定属性值，而是由属性值来确定记录的位置         |                       |                              |
| 树表查找     | 动态查找表     | 以树结构存储数据                                             |                       | 频繁进行插入和删除数据的操作 |
|              | 1.二叉查找树   | 左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大   | 最好O(logn)、最坏O(n) |                              |
|              | 2.平衡二叉树   | 是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1 | O(logn)               |                              |
|              | 3.B树          | 是一种平衡的多路查找树（每一个结点的孩子数可以多于两个且每一个结点处可以存储多个元素） |                       | 数据集非常大                 |
|              | 3.B+树         | 是一种B树的变形树，将所有叶子结点都链接在一起                |                       | 带有范围的查找               |
| 哈希查找     |                | 通过一个哈希函数计算出数据元素的存储地址                     | O(1)                  | 以空间换时间                 |

#### 138.了解哪些排序算法，并比较一下，以及适用场景

> - 技术点：排序
> - 参考回答：代码详见[十大经典排序算法最强总结（含JAVA代码实现）](https://www.cnblogs.com/guoyaohua/p/8600214.html) 

（要求排序结果从小到大）

| 名称         | 特点                                                         | 时间复杂度               | 空间复杂度   | 稳定性 | 适用                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------ | ------------ | ------ | ------------------------------------------------------------ |
| 冒泡排序     | 重复走访要排序的数列，一次比较两个元素，若较小元素在后则交换，能看到越小的元素会经由交换慢慢浮到数列的顶端 | O(n2)                    | O(1)         | 稳定   | 数据规模较小                                                 |
| 简单选择排序 | 每次都在未排序序列中找最小元素                               | O(n2)                    | O(1)         | 稳定   | 数据规模较小且对稳定性有要求                                 |
| 直接插入排序 | 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入 | 最好O(n)，平均O(n2)      | O(1)         | 稳定   | 数据规模较小且待排序列基本有序                               |
| 希尔排序     | 将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序 | O(nlogn)~ O(n2)          | O(1)         | 不稳定 | 数据规模较大                                                 |
| 归并排序     | 先使每个子序列有序，再使子序列段间有序                       | O(nlogn)                 | O(n)         | 稳定   | 数据规模较大且对稳定性有要求                                 |
| 堆排序       | 近似完全二叉树的结构，子结点的键值或索引总是小于（或大于）其父节点 | O(nlogn)                 | O(1)         | 不稳定 | 数据规模较大，相比快排好处是不会出现最坏情况、需要的辅助空间少 |
| 快速排序     | 取一个记录作为枢轴，经过一趟排序将整段序列分为两个部分，使得数轴左侧都小于枢轴、右侧都大于枢轴；再对这两部分继续进行排序使整个序列达到有序 | 最坏 O(n2)，平均O(nlogn) | O(logn)~O(n) | 不稳定 | 数据规模较大且待排序列无序                                   |

#### 139.快排的基本思路是什么？最差的时间复杂度是多少？如何优化？

技术点：排序

参考回答：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小；再分别对这两部分记录继续进行排序，以达到整个序列有序的目的。当待排序列有序时会出现最坏时间复杂度O(n2)。几种优化方式：

- 当待排序序列的长度较小时采用直接插入排序
- 优化所选取数轴的计算方法，如三数取中
- 迭代取代递归，效率高
- 存储数轴值，节省无必要的交换

#### 140.二叉排序树插入或删除一个节点的过程是怎样的？

技术点：查找

参考回答： 

- 二叉排序树插入操作：先查找该元素是否存在于二叉排列树中并记录其根节点，若没有则比较其和根节点大小后插入相应位置
- 二叉排序树删除操作： 
  - 待删除节点是叶子节点，直接删除即可
  - 待删除节点是仅有左或右子树的节点 ，上移子树即可
  - 待删除节点是左右子树都有的节点 ，用删除节点的直接前驱或直接后继来替换当前节点

#### 141.什么是红黑树？

- 技术点：查找
- 参考回答：红黑树是一种自平衡二叉查找树，包含性质：
  - 节点是红色或黑色
  - 根节点是黑色
  - 叶子节点是黑色
  - 每个红色节点的两个子节点都是黑色
  - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

#### 142.五层协议的体系结构分别是什么？每一层都有哪些协议？

技术点：网络模型、协议

思路：分条解释每层名字以及协议

参考回答： 

- 物理层
- 数据链路层：逻辑链路控制LLC、媒体接入控制MAC
- 网络层：IP协议、地址解析协议ARP、逆地址解析协议RARP、因特网控制报文协议ICMP
- 传输层：传输控制协议TCP、用户数据报协议UDP
- 应用层：文件传输协议FTP、远程登录协议TELNET、超文本传输协议HTTP、域名系统DNS、简单邮件协议SMTP、简单网络管理协议SNMP

#### 143.为何有MAC地址还要IP地址？

技术点：MAC地址、IP地址

参考回答： 

- 每台主机在出厂时都有一个唯一的MAC地址，但是IP地址的分配是根据网络的拓朴结构，得以保证路由选择方案建立在网络所处的拓扑位置基础而不是设备制造商的基础上
- 使用IP地址更方便数据传输。数据包在这些节点之间的移动都是由ARP协议负责将IP地址映射到MAC地址上来完成的。

#### 144.TCP和UDP的区别？

技术点：传输层协议对比

参考回答： 

- TCP传输控制协议：面向连接；使用全双工的可靠信道；提供可靠的服务，即无差错、不丢失、不重复且按序到达；拥塞控制、流量控制、超时重发、丢弃重复数据等等可靠性检测手段；面向字节流；每条TCP连接只能是点到点的；用于传输可靠性要求高的数据
- UDP用户数据报协议：无连接；使用不可靠信道；尽最大努力交付，即不保证可靠交付；无拥塞控制等；面向报文；支持一对一、一对多、多对一和多对多的交互通信；用于传输可靠性要求不高的数据

#### 145.拥塞控制和流量控制都是什么，两者的区别？

技术点：拥塞控制、流量控制

参考回答： 

- 拥塞控制：对网络中的路由和链路传输进行速度限制，避免网络过载；包含四个过程：慢启动、拥塞避免、快重传和快恢复
- 流量控制 ：对点和点/发送方和接收方之间进行速度匹配，由于接收方的应用程序读取速度不一定很迅速，加上缓存有限，因此需要避免发送速度过快；相关技术：TCP滑动窗口、回退N针协议。

#### 146.谈谈TCP为什么要三次握手？为什么要四次挥手？

技术点：TCP可靠保证

参考回答：

（1）建立TCP连接：TCP的三次握手



![img](https:////upload-images.jianshu.io/upload_images/5494434-3fb67a464e131e2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/491/format/webp)



- 客户端向服务端发送一个表示建立连接的报文段SYN报文段；一旦包含SYN报文段的IP数据报到达服务器主机，服务器从IP数据报中提取出TCP、SYN报文段，为该TCP连接分配需要的缓存和变量，并向客户端发送表示允许连接的报文段ACK；在收到ACK报文段之后，客户端也要给该连接分配缓存和变量，客户端向服务器再发送一个报文段ACK，表示对允许连接的报文段进行了确认。自此完成一次TCP连接。
- 第三次握手可以避免由于客户端延迟的请求连接的请求，使得服务端无故再次建立连接。

（2）断开TCP连接：TCP的四次挥手



![img](https:////upload-images.jianshu.io/upload_images/5494434-d870028582b03dbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/653/format/webp)



- 由于TCP连接是全双工的，因此每个方向都必须单独关闭。客户端在数据发送完毕后发送一个结束数据段FIN，且服务端也返回确认数据段ACK，此时结束了客户端到服务端的连接；然后客户端接收到服务端发送的FIN，且服务端也收到了ACK之后，自此双方的数据通信完全结束。简单说来是 “先关读，后关写”，一共需要四个阶段：服务器读通道关闭->客户机写通道关闭->客户机读通道关闭->服务器写通道关闭。

引申：谈谈客户端到达的TIME_WAIT状态时间是MaximumSegmentLifetime的两倍，而不是直接进入CLOSED状态的原因。（保证TCP协议的全双工连接能够可靠关闭、保证本次连接的重复数据段从网络中消失）

#### 147.播放视频用TCP还是UDP？为什么？

技术点：传输层协议适用场景

参考回答：播放视频适合用UDP。UDP适用于对网络通讯质量要求不高、要求网络通讯速度能尽量快的实时性应用；而TCP适用于对网络通讯质量有要求的可靠性应用。而且视频区分关键帧和普通帧，虽然UDP会丢帧但如果只是丢普通帧损失并不大，取而代之的是高速率和实时性。

引申：TCP、UDP适用的场景

#### 148.了解哪些响应状态码？

技术点：响应状态码

思路：

参考回答：状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类： 

- 1xx：表示服务器已接收了客户端请求，客户端可继续发送请求
- 2xx：表示服务器已成功接收到请求并进行处理 
  - 200 OK：表示客户端请求成功
- 3xx：表示服务器要求客户端重定向
- 4xx：表示客户端的请求有非法内容 
  - 400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解
  - 401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用
  - 403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因
  - 404 Not Found：请求的资源不存在，例如，输入了错误的URL
- 5xx：表示服务器未能正常处理客户端的请求而出现意外错误 
  - 500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求
  - 503 Service Unavailable：表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常

#### 149.get和post的区别？

技术点：HTTP请求方法

参考回答： 

- GET：当客户端要从服务器中读取某个资源时使用GET；一般用于获取/查询资源信息；GET参数通过URL传递，传递的参数是有长度限制，不能用来传递敏感信息
- POST：当客户端给服务器提供信息较多时可以使用POST；POST会附带用户数据，一般用于更新资源信息；POST将请求参数封装在HTTP 请求数据中，可以传输大量数据，传参方式比GET更安全

#### 150.HTTP1.0、HTTP1.1、HTTP2.0的区别

技术点：HTTP协议发展

参考回答：

（1）HTTP1.0和HTTP1.1的区别： 

- HTTP1.0默认使用短连接，HTTP1.1开始默认使用长连接
- HTTP1.1增加更多的请求头和响应头来改进和扩充HTTP1.0的功能，比如身份认证、状态管理和Cache缓存等

（2）HTTP2.0和HTTP1.X相比的新特性： 

- 新的二进制格式：HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮，不同于HTTP1.x的解析是基于文本
- 多路复用：连接共享，即每一个request都是是用作连接共享机制的
- 服务端推送：服务器主动向客户端推送消息

引申：长连接和短连接的优缺点和适用场景，[HTTP 长连接和短连接](https://www.jianshu.com/p/caeec6bd1d3f)

#### 151.HTTP和TCP的区别

- 技术点：HTTP、TCP
- 参考回答：
  - TCP是传输层协议，定义数据传输和连接方式的规范。通过三次握手建立连接、四次挥手释放连接。
  - HTTP是应用层协议，定义的是传输数据的内容的规范。HTTP的连接使用"请求-响应"方式。基于TCP协议传输，默认端口号是80。

#### 152.HTTP和HTTPS的区别

技术点：HTTP、HTTPS

- HTTP（超文本传输协议）：运行在TCP之上；传输的内容是明文；端口是80
- HTTPS（安全为目标的HTTP）：运行在SSL/TLS之上，SSL/TLS运行在TCP之上；传输的内容经过加密；端口是443

#### 153.HTTP和Socket的区别

技术点：HTTP、Socket

参考回答： 

- HTTP是应用层协议；基于TCP协议；使用“请求—响应”方式建立连接，在请求时需要先建立连接且客户端要先发出请求，可见服务器需要等到客户端发送一次请求后才能将数据传回给客户端
- Socket（套接字）是对TCP/IP协议的封装，是接口而不是协议；创建Socket连接时可以指定传输层协议TCP或UDP；Socket建立连接过程三步骤：服务器监听->客户端请求->连接确认，可见服务器可以直接将数据传送给客户端（HTTP2.0也增加了服务端推送的功能）

#### 154.JVM内存是如何划分的？

技术点：JVM内存管理

思路：分条解释每部分内存的作用，详见[要点提炼| 理解JVM之内存管理](https://www.jianshu.com/p/cd93567ed868) 

参考回答：JVM会用一段空间来存储执行程序期间需要用到的数据和相关信息，这段空间就是

运行时数据区（Runtime Data Area）

，也就是常说的JVM内存。JVM会将它所管理的内存划分为

线程私有数据区

和

线程共享数据区

两大类： 

- 线程私有数据区包含： 
  - 程序计数器：是**当前线程**所执行的字节码的行号指示器
  - 虚拟机栈：是**Java方法**执行的内存模型
  - 本地方法栈：是虚拟机使用到的**Native方法**服务
- 线程共享数据区包含： 
  - Java堆：用于存放几乎所有的对象实例和数组；是垃圾收集器管理的主要区域，也被称做“GC堆”；是Java虚拟机所管理的内存中最大的一块
  - 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池（Constant Pool Table）**，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放

引申：谈谈JVM的堆和栈差别

#### 155.谈谈垃圾回收机制？为什么引用计数器判定对象是否回收不可行？知道哪些垃圾回收算法？

技术点：垃圾回收机制

思路：从如何判定对象可回收、如果回收具体算法这两方面展开谈垃圾回收机制，详见[要点提炼| 理解JVM之GC](https://www.jianshu.com/p/a62697f00b85) 

参考回答：

（1）判定对象可回收有两种方法： 

-  **引用计数算法**：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。然而在主流的Java虚拟机里未选用引用计数算法来管理内存，主要原因是它难以解决对象之间**相互循环引用**的问题，所以出现了另一种对象存活判定算法。
-  **可达性分析法**：通过一系列被称为『GC Roots』的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。其中可作为GC Roots的对象：虚拟机栈中引用的对象，主要是指栈帧中的**本地变量**、本地方法栈中**Native方法**引用的对象、方法区中**类静态属性**引用的对象、方法区中**常量**引用的对象

（2）回收算法有以下四种： 

- 分代收集算法

  ：是当前商业虚拟机都采用的一种算法，根据对象存活周期的不同，将Java堆划分为新生代和老年代，并根据各个年代的特点采用最适当的收集算法。 

  - 新生代：大批对象死去，只有少量存活。使用『复制算法』，只需复制少量存活对象即可。 
    -  **复制算法**：把可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用尽后，把还存活着的对象『复制』到另外一块上面，再将这一块内存空间一次清理掉。
  - 老年代：对象存活率高。使用『标记—清理算法』或者『标记—整理算法』，只需标记较少的回收对象即可。 
    -  **标记-清除算法**：首先『标记』出所有需要回收的对象，然后统一『清除』所有被标记的对象。
    -  **标记-整理算法**：首先『标记』出所有需要回收的对象，然后进行『整理』，使得存活的对象都向一端移动，最后直接清理掉端边界以外的内存。

引申：谈谈每种回收算法的优缺点

#### 156.Java中引用有几种类型？在Android中常用于什么情景？

技术点：Java引用类型

思路：分条解释每种类型的特点和适用场景，详见[要点提炼| 理解JVM之GC](https://www.jianshu.com/p/a62697f00b85) 

参考回答：引用的四种类型 

-  **强引用**（StrongReference）：具有强引用的对象不会被GC；即便内存空间不足，JVM宁愿抛出OutOfMemoryError使程序异常终止，也不会随意回收具有强引用的对象。
-  **软引用**（SoftReference）：只具有软引用的对象，会在内存空间不足的时候被GC；软引用常用来实现内存敏感的高速**缓存**。
-  **弱引用**（WeakReference）：只被弱引用关联的对象，无论当前内存是否足够都会被GC；强度比软引用更弱，常用于描述**非必需**对象；常用于解决内存泄漏的问题
-  **虚引用**（PhantomReference）：仅持有虚引用的对象，在任何时候都可能被GC；常用于跟踪对象被GC回收的活动；必须和**引用队列** （ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

#### 157.类加载的全过程是怎样的？什么是双亲委派模型？

技术点：类加载机制、双亲委派模型

思路：类加载机制的含义以及每个阶段的作用，在解释双亲委派模型之前需要先理解类加载器，详见[要点提炼| 理解JVM之类加载机制](https://www.jianshu.com/p/9ea809edebb6) 

参考回答：

（1）类加载机制：是虚拟机把描述类的数据从Class文件

加载

到内存，并对数据进行

校验

、

转换解析

和

初始化

，最终形成可被虚拟机直接使用的Java类型的过程。另外，类型的加载、连接和初始化过程都是在程序

运行期

完成的，从而通过牺牲一些性能开销来换取Java程序的高度灵活性。下面介绍类加载每个阶段的任务： 

-  **加载**（Loading）：通过类的全限定名来获取定义此类的**二进制字节流**；将该二进制字节流所代表的**静态存储结构**转化为方法区的**运行时数据结构**，该数据存储数据结构由虚拟机实现自行定义；在内存中生成一个代表这个类的java.lang.Class对象，它将作为程序访问方法区中的这些类型数据的外部接口
-  **验证**（Verification）：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，包括文件格式验证、元数据验证、字节码验证和符号引用验证
-  **准备**（Preparation）：为类变量**分配内存**，因为这里的变量是由方法区分配内存的，所以仅包括类变量而不包括实例变量，后者将会在对象实例化时随着对象一起分配在Java堆中；设置类变量**初始值**，通常情况下零值
-  **解析**（Resolution）：虚拟机将**常量池**内的符号引用替换为直接引用的过程
-  **初始化**（Initialization）：是类加载过程的最后一步，会开始真正执行类中定义的Java字节码。而之前的类加载过程中，除了在『加载』阶段用户应用程序可通过自定义类加载器参与之外，其余阶段均由虚拟机主导和控制

（2）类加载器：不仅用于加载类，还和这个类本身一起作为在JVM中的唯一标识。常见类加载器类型有： 

- 启动类加载器：是虚拟机自身的一部分
- 扩展类加载器、应用程序类加载器、自定义类加载器：独立于虚拟机外部

（3）双亲委派模型：表示类加载器之间的层次关系。 

-  **前提**：除了顶层启动类加载器外，其余类加载器都应当有自己的父类加载器，且它们之间关系一般不会以**继承**（Inheritance）关系来实现，而是通过**组合**（Composition）关系来复用父加载器的代码。
-  **工作过程**：若一个类加载器收到了类加载的请求，它先会把这个请求**委派**给父类加载器，并向上传递，最终请求都传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

#### 158.工作内存和主内存的关系？在Java内存模型有哪些可以保证并发过程的原子性、可见性和有序性的措施？

技术点：JVM内存模型、线程安全

思路：理解Java内存模型的结构、详见[要点提炼| 理解JVM之内存模型&线程](https://www.jianshu.com/p/90a036212cb4) 

参考回答：Java内存模型就是通过定义程序中各个

变量

的

访问规则

，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。 

- 模型结构如图：

  

  ![img](https:////upload-images.jianshu.io/upload_images/5494434-ef7d2326ec7a3120.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/838/format/webp)

  

   其中 ，

  主内存

  （Main   Memory）是所有变量的存储位置，每条线程还有自己的

  工作内存

  ，用于保存被该线程使用到的变量的主内存副本拷贝。为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中。

- 保证并发过程的原子性、可见性和有序性的措施： 

  - 原子性

    （Atomicity）：一个操作要么都执行要么都不执行。 

    - 可直接保证的原子性变量操作有：`read`、`load`、`assign`、`use`、`store`和`write`，因此可认为基本数据类型的访问读写是具备原子性的。
    - 若需要保证更大范围的原子性，可通过更高层次的字节码指令`monitorenter`和`monitorexit`来隐式地使用`lock`和`unlock`这两个操作，反映到Java代码中就是同步代码块`synchronized`关键字。

  - 可见性

    （Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 

    - 通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现。
    - 提供三个关键字保证可见性：`volatile`能保证新值能**立即**同步到主内存，且每次使用前立即从主内存刷新；`synchronized`对一个变量执行unlock操作之前可以先把此变量同步回主内存中；被`final`修饰的字段在构造器中一旦初始化完成且构造器没有把`this`的引用传递出去，就可以在其他线程中就能看见final字段的值。

  - 有序性

    （Ordering）：程序代码按照指令顺序执行。 

    - 如果在本线程内观察，所有的操作都是有序的，指“线程内表现为串行的语义”；如果在一个线程中观察另一个线程，所有的操作都是无序的，指“指令重排序”现象和“工作内存与主内存同步延迟”现象。
    - 提供两个关键字保证有序性：`volatile` 本身就包含了禁止指令重排序的语义；`synchronized`保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入。

#### 159.JVM、Dalvik、ART的区别？

技术点：虚拟机对比

思路：分别谈谈JVM和Dalvik、Dalvik和ART的区别，详见[Jvm、Dalvik和Art的区别](https://www.jianshu.com/p/59d98244fb52) 

参考回答： 

- 

  

   Dalvik ：是Google公司自己设计用于Android平台的Java虚拟机，不是Java虚拟机，没有遵循Java虚拟机规范，具体区别如下图：

  

  ![img](https:////upload-images.jianshu.io/upload_images/5494434-15869d2560d1fbc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

  

- ART：代替Dalvik，应用无需每次运行都要先编译，而是在安装时就**预编译**字节码到机器语言，提升运行时效率；预先编译也使得ART占用空间比Dalvik大，即用空间换时间；由于减少运行时重复编译，可明显改善电池续航，降低了能耗。

#### 160.Java中堆和栈的区别？

技术点：内存管理

思路：从存放数据和内存回收角度出发

参考回答： 在java中，堆和栈都是内存中存放数据的地方，具题区别是： 

- 栈内存：主要用来存放**基本数据类型**和**局部变量**；当在代码块定义一个变量时会在栈中为这个变量分配内存空间，当超过变量的作用域后这块空间就会被自动释放掉。
- 堆内存：用来存放**运行时创建的对象**，比如通过new关键字创建出来的对象和数组；需要由Java虚拟机的自动垃圾回收器来管理。

#### 161.操作系统中进程和线程的区别？

- 技术点：进程、线程
- 参考回答：
  - 进程是操作系统分配和管理资源的单位，线程是CPU调度和管理的单位，是CPU调度的最小单元
  - 进程拥有独立的地址空间，而线程间共享地址空间
  - 进程创建的开销比较大，线程创建的开销小
- 引申：可谈谈安卓系统中对进程和线程的理解

#### 162.进程死锁的产生和避免?

技术点：死锁

思路：可从死锁含义、产生条件、解决办法、避免手段出发

参考回答：死锁是指多个进程因循环等待资源而造成无法执行的现象，它会造成进程无法执行，同时会造成系统资源的极大浪费。 

- 死锁产生的条件： 
  - 互斥使用：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
  - 不可抢占：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
  - 请求和保持：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
  - 循环等待：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
- 解决死锁的策略： 
  - 银行家算法：判断此次请求是否造成死锁若会造成死锁，否则拒绝该请求
  - 鸵鸟算法：忽略该问题，常用于在极少发生死锁的的情况
- 死锁的避免：通过合理的资源分配算法来确保永远不会形成环形等待的封闭进程链，即“如果一个进程的当前请求的资源会导致死锁，系统拒绝启动该进程；如果一个资源的分配会导致下一步的死锁，系统就拒绝本次的分配”

#### 163.谈谈MVC、MVP和MVVM，好在哪里，不好在哪里？

技术点：MVC、MVP、MVVM

思路：详见[MVP、MVVM模式](https://www.jianshu.com/p/e0867ac2a261) 

参考回答： 

- MVP的含义： 

  -  **Model**：数据层，负责存储、检索、操纵数据。
  -  **View：UI**层，显示数据，并向Presenter报告用户行为。
  -  **Presenter**：作为View与Model交互的中间纽带，从Model拿数据，应用到UI层，管理UI的状态，响应用户的行为。

- MVP相比于MVC的

  优势

  ： 

  - 分离了视图逻辑和业务逻辑，降低了耦合。
  - Activity只处理生命周期的任务，代码变得更加**简洁**。
  - 视图逻辑和业务逻辑分别抽象到了View和Presenter的**接口**中去，提高代码的可阅读性。
  - Presenter被抽象成接口，可以有多种具体的实现，所以方便进行**单元测试**。
  - 把业务逻辑抽到Presenter中去，避免后台线程引用着Activity导致Activity的资源无法被系统回收从而引起**内存泄露**和OOM。

- MVVM的含义：与MVP类似，利用**数据绑定**(Data Binding)、**依赖属性**(Dependency Property)、**命令**(Command)、**路由事件**(Routed Event)等新特性，打造了一个更加灵活高效的架构。

- MVVM相比于MVP的**优势**：在常规的开发模式中，数据变化需要更新UI的时候，需要先获取UI控件的引用，然后再更新UI，获取用户的输入和操作也需要通过UI控件的引用，但在MVVM中，这些都是通过**数据驱动**来自动完成的，数据变化后会自动更新UI，UI的改变也能自动反馈到数据层，数据成为主导因素。这样MVVM层在业务逻辑处理中只要关心数据，不需要直接和UI打交道，在业务处理过程中简单方便很多。

#### 164.如何理解生产者消费者模型？

技术点：生产者消费者模型

参考回答：生产者消费者模型通过一个缓存队列，既解决了生产者和消费者之间强耦合的问题，又平衡了生产者和消费者的处理能力。 

- 具体规则：生产者只在缓存区未满时进行生产，缓存区满时生产者进程被阻塞；消费者只在缓存区非空时进行消费，缓存区为空时消费者进程被阻塞；当消费者发现缓存区为空时会通知生产者生产；当生产者发现缓存区满时会通知消费者消费。
- 实现关键：synchronized保证对象只能被一个线程占用；wait()让当前线程进入等待状态，并释放它所持有的锁；notify()&notifyAll()唤醒一个（所有）正处于等待状态的线程

#### 165.是否能从Android中举几个例子说说用到了什么设计模式？

- 技术点：设计模式
- 参考回答：
  - View事件分发：责任链模式
  - BitmapFactory加载图片：工厂模式
  - Adapter：适配器模式
  - Builder：建造者模式
  - Adpter.notifyDataSetChanged()：观察者模式
  - Binder机制：代理模式

#### 166.装饰模式和代理模式有哪些区别？

技术点：装饰模式、代理模式

参考回答： 

- 使用目的不同：代理模式是给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用；装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能
- 构造不同：代理模式内部保持对目标对象的引用；装饰模式是通过构造函数传参的方式得到目标对象

#### 167.谈谈了解的设计模式原则？

技术点：设计模式原则

参考回答： 

- 单一职责原则：一个类只负责一个功能领域中的相应职责
- 开放封闭原则：对扩展开放，对修改关闭
- 依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程
- 迪米特法则：应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用
- 合成/聚合复用原则：要尽量使用合成/聚合，尽量不要使用继承

#### 168.数据库中的事务了解吗？事务的四大特性？

技术点：事务

参考回答： 

- 事务是并发控制的单位，是用户定义的一个操作序列。它指这些操作要么都做，要么都不做，以便服务器保持数据的完整性。
- 事务通常是以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。
- 事务的四大特性（ACID特性）：原子性（Atomicity）表示事务中包括的诸操作要么全做，要么全不做；一致性（Consistency）表示事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态；隔离性（Isolation）表示一个事务的执行不能被其他事务干扰；持续性（Durability）表示一个事务一旦提交，它对数据库中数据的改变就应该是永久性的

引申：谈谈[数据库事务的并发控制](https://www.jianshu.com/p/478c6dca1b74)

#### 169.如何理解数据库的范式？

技术点：范式

思路：详见实例讲解[数据库的3大范式和5大约束](https://blog.csdn.net/qq_33862644/article/details/79692652) 

参考回答： 

- 第一范式（1NF）：数据表中的每个字段必须是不可拆分的最小单元，即确保每一列的原子性
- 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系
- 第三范式（3NF）：必须先满足第二范式，要求表中的每一列只与主键直接相关而不是间接相关，即表中的每一列只能依赖于主键

#### 170.使用那些版本控制工具？Git和SVN的区别？

技术点：版本控制工具

参考回答：Git和SVN的区别有以下几点： 

- Git是分布式的，而SVN是集中式的（核心区别）
- Git按元数据方式存储内容，而SVN按文件存储内容
- 在Git上每个工作成员可以任意在自己的本地版本库开启无限个分支且互不影响，而对于SVN分支是一个完整的目录且这个目录拥有完整的实际文件
- Git没有一个全局的版本号，而SVN有
- Git 的内容完整性要优于SVN
- 在Git中的绝大多数操作都只需要访问本地文件和资源，不必联网就可以看到所有的历史版本记录，而SVN 却需要联网

引申：谈谈两种版本控制工具的优缺点：[SVN与GIT的优缺点对比](https://blog.csdn.net/u013594477/article/details/80828842)

#### 171.了解Git工具吗？用过哪些命令？解决冲突时git merge和git rebase的区别？

技术点：版本控制工具Git

思路：通过图记忆Git常用命令，详见[Git、GitHub、Stash](https://www.jianshu.com/p/e0867ac2a261) 

参考回答： 常用命令见图，源自

一篇文章，教你学会Git



![img](https:////upload-images.jianshu.io/upload_images/5494434-3fa594a96f4e693f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)



 合并用到的命令git merge与git rebase的区别是，git merge会生成一个新的节点，并将之前的提交分开显示；git rebase操作不会生成新的节点，而是将两个分支融合成一个线性的提交。

#### 172.协程,用过那些高阶函数

协程：区别于子线程，在主线程中一个任务做到一半去执行另一个任务，再返回执行该任务的流程叫做协程

#### 173.apk打包过程

![](D:\学习\面试相关\apk打包过程.webp)

1.aapt阶段：使用aapt来打包res资源文件，生成R.java,resources.arsc和res文件（二进制 & 非二进制如res/raw和pic保持原样）

2.aidl阶段：处理.aidl文件，生成对应的Java接口文件。

3.Java Compiler阶段：通过Java Compiler编译R.java、java接口文件、java源文件，生成.class文件

4.dex阶段：通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex

5.apkbuilder阶段：将classes.dex、resources.arsc、res文件夹、other resources（assets文件夹）AndroidManifest打包到apk文件。

6.Jarsigner阶段：对apk进行签名，可以进行debug和release的签名

7.zipalign阶段：对签名后的apk进行对齐处理便于读取。

#### 174.rxjava线程切换原理

上游observeable一层层调用包装调用的下游的observeable，在此过程中对添加observeableOn切换的线程的每个环节对应的observeable进行线程关联，而subscribeOn指定的线程只有在上游事件发射的时候进行了关联，所以当到最下游的Observeable后在层层回调到最上游的的发射时间，然后往下游调用onNext方法，期间线程进行切换，到达subscribe的onNext事件时指定的是最上游的subscriberOn指定的线程。

#### 175.apk启动过程 androidmanifest什么时候被解析

- android系统启动之后会解析固定目录下的apk文件，并执行解析，持久化apk信息，重新安装等操作；
- 解析Manifest流程：Zygote进程 –> SystemServer进程 –> PackgeManagerService服务 –> scanDirLI方法 –> scanPackageLI方法 –> PackageParser.parserPackage方法；
- 解析完成Manifest之后会将apk的Manifest信息保存在Settings对象中并持久化，然后执行重新安装的操作。

#### 176.okhttp原理 拦截器链和android中的什么设计模式一样

使用了责任链模式，有多个拦截器组成的链式调用结构，自上而下拦截器有RetryAndFollowUpInterceptor(处理请求失败的重试，重定向)、BrigeInterceptor（添加请求头或其他信息）、CacheInterceptor（判断缓存是否存在，读取缓存，更新缓存等等）、ConnectInterceptor（建立客户端和服务端的连接）、CallServerInterceptor，发送请求request后，经过层层的Interceptor返回responce。

和android中的view的事件分发使用的设计模式一样。

#### 177.retrofit优缺点

优点： 
可以配置不同HTTP client来实现网络请求，如okhttp、httpclient等，请求的方法参数注解都可以定制 
支持同步、异步和RxJava 超级解耦 可以配置不同的反序列化工具来解析数据，如json、xml等 使用非常方便灵活 框架使用了很多设计模式(感兴趣的可以看看源码学习学习) 
缺点： 
不能接触序列化实体和响应数据 执行的机制太严格 使用转换器比较低效 只能支持简单的自定义参数类型。

#### 178.协程和进程有什么区别

略。

#### 179.http和https ssl怎么验证

https相对于http的不同点：

1.https需要用到CA申请证书

2.http是超文本传输协议，信息是明文的；https则是具有安全性的SSL加密传输协议

3.http和https使用的完全不同的连接方式，用的端口也不一样，http是80端口，https是443端口

4.http的连接很简单是无状态的，https是http+ssl协议构成的，可进行加密传输、身份认证的网络协议，比http更加安全。

SSL协议通信过程

(1) 浏览器发送一个连接请求给服务器;服务器将自己的证书(包含服务器公钥S_PuKey)、对称加密算法种类及其他相关信息返回客户端;

(2) 客户端浏览器检查服务器传送到CA证书是否由自己信赖的CA中心签发。若是，执行4步;否则，给客户一个警告信息：询问是否继续访问。

(3) 客户端浏览器比较证书里的信息，如证书有效期、服务器域名和公钥S_PK，与服务器传回的信息是否一致，如果一致，则浏览器完成对服务器的身份认证。

(4) 服务器要求客户端发送客户端证书(包含客户端公钥C_PuKey)、支持的对称加密方案及其他相关信息。收到后，服务器进行相同的身份认证，若没有通过验证，则拒绝连接;

(5) 服务器根据客户端浏览器发送到密码种类，选择一种加密程度最高的方案，用客户端公钥C_PuKey加密后通知到浏览器;

(6) 客户端通过私钥C_PrKey解密后，得知服务器选择的加密方案，并选择一个通话密钥key，接着用服务器公钥S_PuKey加密后发送给服务器;

(7) 服务器接收到的浏览器传送到消息，用私钥S_PrKey解密，获得通话密钥key。

(8) 接下来的数据传输都使用该对称密钥key进行加密。

#### 180.304状态码 http缓存

304状态码代表服务端存在缓存。

#### 181.为什么要用kotlin kotlin特性

略

#### 182.rehash和hash hashmap hash算法的用处 头插 尾插

#### 183.sp原理

#### 184.android里面替换hashmap的类

#### 185.context的设计模式

#### 186.okhttp拦截器链 每个拦截器的作用 okhttp有哪些设计得比较好的地方

#### 187.如何判断一个单链表是否有环

#### 188.android中webview如何处理加载的页面图片过多的问题

#### 189.Glide如何和android生命周期绑定

#### 190.gc什么时候回收，对什么东西回收，做了什么操作

#### 191.http怎么知道文件过大是否传输完毕的响应

#### 192.activity启动流程

#### 193.glide 缓存 lrucache linkhashmap 二叉树 扩容机制

#### 194.rxjava的flatmap怎么实现的

#### 195.hashmap java1.8之后的优化 红黑树和BL树的区别

#### 196.java内存模型

#### 197.java GC算法

#### 198.rxjava dispose里面做了什么事情

#### 199.Invalidate、postInvalidate、requestLayout应用场景

#### 200.类加载的过程，加载、验证、准备、解析、初始化。每个部分详细描述。

#### 201.listview缓存机制、recycleview缓存机制。

#### 202.framework有哪方面什么理解









